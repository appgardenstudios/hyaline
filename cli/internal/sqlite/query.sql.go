// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlite

import (
	"context"
)

const deleteDocumentTagsForSource = `-- name: DeleteDocumentTagsForSource :exec
DELETE FROM DOCUMENT_TAG WHERE SOURCE_ID = ?
`

func (q *Queries) DeleteDocumentTagsForSource(ctx context.Context, sourceID string) error {
	_, err := q.db.ExecContext(ctx, deleteDocumentTagsForSource, sourceID)
	return err
}

const deleteDocumentsForSource = `-- name: DeleteDocumentsForSource :exec
DELETE FROM DOCUMENT WHERE SOURCE_ID = ?
`

func (q *Queries) DeleteDocumentsForSource(ctx context.Context, sourceID string) error {
	_, err := q.db.ExecContext(ctx, deleteDocumentsForSource, sourceID)
	return err
}

const deleteSectionTagsForSource = `-- name: DeleteSectionTagsForSource :exec
DELETE FROM SECTION_TAG WHERE SOURCE_ID = ?
`

func (q *Queries) DeleteSectionTagsForSource(ctx context.Context, sourceID string) error {
	_, err := q.db.ExecContext(ctx, deleteSectionTagsForSource, sourceID)
	return err
}

const deleteSectionsForSource = `-- name: DeleteSectionsForSource :exec
DELETE FROM SECTION WHERE SOURCE_ID = ?
`

func (q *Queries) DeleteSectionsForSource(ctx context.Context, sourceID string) error {
	_, err := q.db.ExecContext(ctx, deleteSectionsForSource, sourceID)
	return err
}

const deleteSource = `-- name: DeleteSource :exec
DELETE FROM SOURCE WHERE ID = ?
`

func (q *Queries) DeleteSource(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSource, id)
	return err
}

const getAllDocumentTags = `-- name: GetAllDocumentTags :many
SELECT
  SOURCE_ID, DOCUMENT_ID, TAG_KEY, TAG_VALUE
FROM
  DOCUMENT_TAG
ORDER BY
  SOURCE_ID, DOCUMENT_ID, TAG_KEY, TAG_VALUE
`

func (q *Queries) GetAllDocumentTags(ctx context.Context) ([]DOCUMENTTAG, error) {
	rows, err := q.db.QueryContext(ctx, getAllDocumentTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DOCUMENTTAG
	for rows.Next() {
		var i DOCUMENTTAG
		if err := rows.Scan(
			&i.SourceID,
			&i.DocumentID,
			&i.TagKey,
			&i.TagValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDocumentTagsForSource = `-- name: GetAllDocumentTagsForSource :many
SELECT
  DOCUMENT_ID, TAG_KEY, TAG_VALUE
FROM
  DOCUMENT_TAG
WHERE
  SOURCE_ID = ?
ORDER BY
  DOCUMENT_ID, TAG_KEY, TAG_VALUE
`

type GetAllDocumentTagsForSourceRow struct {
	DocumentID string
	TagKey     string
	TagValue   string
}

func (q *Queries) GetAllDocumentTagsForSource(ctx context.Context, sourceID string) ([]GetAllDocumentTagsForSourceRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllDocumentTagsForSource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllDocumentTagsForSourceRow
	for rows.Next() {
		var i GetAllDocumentTagsForSourceRow
		if err := rows.Scan(&i.DocumentID, &i.TagKey, &i.TagValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDocuments = `-- name: GetAllDocuments :many
SELECT
  ID, SOURCE_ID, TYPE, PURPOSE, RAW_DATA, EXTRACTED_DATA
FROM
  DOCUMENT
ORDER BY
  SOURCE_ID, ID
`

func (q *Queries) GetAllDocuments(ctx context.Context) ([]DOCUMENT, error) {
	rows, err := q.db.QueryContext(ctx, getAllDocuments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DOCUMENT
	for rows.Next() {
		var i DOCUMENT
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Type,
			&i.Purpose,
			&i.RawData,
			&i.ExtractedData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSectionTags = `-- name: GetAllSectionTags :many
SELECT
  SOURCE_ID, DOCUMENT_ID, SECTION_ID, TAG_KEY, TAG_VALUE
FROM
  SECTION_TAG
ORDER BY
  SOURCE_ID, DOCUMENT_ID, SECTION_ID, TAG_KEY, TAG_VALUE
`

func (q *Queries) GetAllSectionTags(ctx context.Context) ([]SECTIONTAG, error) {
	rows, err := q.db.QueryContext(ctx, getAllSectionTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SECTIONTAG
	for rows.Next() {
		var i SECTIONTAG
		if err := rows.Scan(
			&i.SourceID,
			&i.DocumentID,
			&i.SectionID,
			&i.TagKey,
			&i.TagValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSectionTagsForSource = `-- name: GetAllSectionTagsForSource :many
SELECT
  DOCUMENT_ID, SECTION_ID, TAG_KEY, TAG_VALUE
FROM
  SECTION_TAG
WHERE
  SOURCE_ID = ?
ORDER BY
  DOCUMENT_ID, SECTION_ID, TAG_KEY, TAG_VALUE
`

type GetAllSectionTagsForSourceRow struct {
	DocumentID string
	SectionID  string
	TagKey     string
	TagValue   string
}

func (q *Queries) GetAllSectionTagsForSource(ctx context.Context, sourceID string) ([]GetAllSectionTagsForSourceRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSectionTagsForSource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSectionTagsForSourceRow
	for rows.Next() {
		var i GetAllSectionTagsForSourceRow
		if err := rows.Scan(
			&i.DocumentID,
			&i.SectionID,
			&i.TagKey,
			&i.TagValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSections = `-- name: GetAllSections :many
SELECT
  ID, DOCUMENT_ID, SOURCE_ID, PARENT_ID, PEER_ORDER, NAME, PURPOSE, EXTRACTED_DATA
FROM
  SECTION
ORDER BY
  SOURCE_ID, DOCUMENT_ID, PEER_ORDER, ID
`

func (q *Queries) GetAllSections(ctx context.Context) ([]SECTION, error) {
	rows, err := q.db.QueryContext(ctx, getAllSections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SECTION
	for rows.Next() {
		var i SECTION
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.SourceID,
			&i.ParentID,
			&i.PeerOrder,
			&i.Name,
			&i.Purpose,
			&i.ExtractedData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSectionsForSource = `-- name: GetAllSectionsForSource :many
SELECT
  ID, DOCUMENT_ID, SOURCE_ID, PARENT_ID, PEER_ORDER, NAME, PURPOSE, EXTRACTED_DATA
FROM
  SECTION
WHERE
  SOURCE_ID = ?
ORDER BY
  DOCUMENT_ID, PEER_ORDER, ID
`

func (q *Queries) GetAllSectionsForSource(ctx context.Context, sourceID string) ([]SECTION, error) {
	rows, err := q.db.QueryContext(ctx, getAllSectionsForSource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SECTION
	for rows.Next() {
		var i SECTION
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.SourceID,
			&i.ParentID,
			&i.PeerOrder,
			&i.Name,
			&i.Purpose,
			&i.ExtractedData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSources = `-- name: GetAllSources :many
SELECT
  ID, DESCRIPTION, CRAWLER, ROOT
FROM
  SOURCE
ORDER BY
  ID
`

func (q *Queries) GetAllSources(ctx context.Context) ([]SOURCE, error) {
	rows, err := q.db.QueryContext(ctx, getAllSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SOURCE
	for rows.Next() {
		var i SOURCE
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Crawler,
			&i.Root,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentIDsForSource = `-- name: GetDocumentIDsForSource :many
SELECT
  ID
FROM
  DOCUMENT
WHERE
  SOURCE_ID = ?
`

func (q *Queries) GetDocumentIDsForSource(ctx context.Context, sourceID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDocumentIDsForSource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentTags = `-- name: GetDocumentTags :many
SELECT
  TAG_KEY, TAG_VALUE
FROM
  DOCUMENT_TAG
WHERE
  SOURCE_ID = ? AND DOCUMENT_ID = ?
ORDER BY
  TAG_KEY, TAG_VALUE
`

type GetDocumentTagsParams struct {
	SourceID   string
	DocumentID string
}

type GetDocumentTagsRow struct {
	TagKey   string
	TagValue string
}

func (q *Queries) GetDocumentTags(ctx context.Context, arg GetDocumentTagsParams) ([]GetDocumentTagsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDocumentTags, arg.SourceID, arg.DocumentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentTagsRow
	for rows.Next() {
		var i GetDocumentTagsRow
		if err := rows.Scan(&i.TagKey, &i.TagValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentsForSource = `-- name: GetDocumentsForSource :many
SELECT
  ID, SOURCE_ID, TYPE, PURPOSE, RAW_DATA, EXTRACTED_DATA
FROM
  DOCUMENT
WHERE
  SOURCE_ID = ?
ORDER BY
  ID
`

func (q *Queries) GetDocumentsForSource(ctx context.Context, sourceID string) ([]DOCUMENT, error) {
	rows, err := q.db.QueryContext(ctx, getDocumentsForSource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DOCUMENT
	for rows.Next() {
		var i DOCUMENT
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Type,
			&i.Purpose,
			&i.RawData,
			&i.ExtractedData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionIDsForSource = `-- name: GetSectionIDsForSource :many
SELECT
  ID, DOCUMENT_ID
FROM
  SECTION
WHERE
  SOURCE_ID = ?
`

type GetSectionIDsForSourceRow struct {
	ID         string
	DocumentID string
}

func (q *Queries) GetSectionIDsForSource(ctx context.Context, sourceID string) ([]GetSectionIDsForSourceRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionIDsForSource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSectionIDsForSourceRow
	for rows.Next() {
		var i GetSectionIDsForSourceRow
		if err := rows.Scan(&i.ID, &i.DocumentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionTags = `-- name: GetSectionTags :many
SELECT
  TAG_KEY, TAG_VALUE
FROM
  SECTION_TAG
WHERE
  SOURCE_ID = ? AND DOCUMENT_ID = ? AND SECTION_ID = ?
ORDER BY
  TAG_KEY, TAG_VALUE
`

type GetSectionTagsParams struct {
	SourceID   string
	DocumentID string
	SectionID  string
}

type GetSectionTagsRow struct {
	TagKey   string
	TagValue string
}

func (q *Queries) GetSectionTags(ctx context.Context, arg GetSectionTagsParams) ([]GetSectionTagsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionTags, arg.SourceID, arg.DocumentID, arg.SectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSectionTagsRow
	for rows.Next() {
		var i GetSectionTagsRow
		if err := rows.Scan(&i.TagKey, &i.TagValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsForDocument = `-- name: GetSectionsForDocument :many
SELECT
  ID, DOCUMENT_ID, SOURCE_ID, PARENT_ID, PEER_ORDER, NAME, PURPOSE, EXTRACTED_DATA
FROM
  SECTION
WHERE
  SOURCE_ID = ? AND DOCUMENT_ID = ?
ORDER BY
  PEER_ORDER, ID
`

type GetSectionsForDocumentParams struct {
	SourceID   string
	DocumentID string
}

func (q *Queries) GetSectionsForDocument(ctx context.Context, arg GetSectionsForDocumentParams) ([]SECTION, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsForDocument, arg.SourceID, arg.DocumentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SECTION
	for rows.Next() {
		var i SECTION
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.SourceID,
			&i.ParentID,
			&i.PeerOrder,
			&i.Name,
			&i.Purpose,
			&i.ExtractedData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDocument = `-- name: InsertDocument :exec
INSERT INTO DOCUMENT (
  ID, SOURCE_ID, TYPE, PURPOSE, RAW_DATA, EXTRACTED_DATA
) VALUES (
  ?, ?, ?, ?, ?, ?
)
`

type InsertDocumentParams struct {
	ID            string
	SourceID      string
	Type          string
	Purpose       string
	RawData       string
	ExtractedData string
}

func (q *Queries) InsertDocument(ctx context.Context, arg InsertDocumentParams) error {
	_, err := q.db.ExecContext(ctx, insertDocument,
		arg.ID,
		arg.SourceID,
		arg.Type,
		arg.Purpose,
		arg.RawData,
		arg.ExtractedData,
	)
	return err
}

const insertSection = `-- name: InsertSection :exec
INSERT INTO SECTION (
  ID, DOCUMENT_ID, SOURCE_ID, PARENT_ID, PEER_ORDER, NAME, PURPOSE, EXTRACTED_DATA
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?
)
`

type InsertSectionParams struct {
	ID            string
	DocumentID    string
	SourceID      string
	ParentID      string
	PeerOrder     interface{}
	Name          string
	Purpose       string
	ExtractedData string
}

func (q *Queries) InsertSection(ctx context.Context, arg InsertSectionParams) error {
	_, err := q.db.ExecContext(ctx, insertSection,
		arg.ID,
		arg.DocumentID,
		arg.SourceID,
		arg.ParentID,
		arg.PeerOrder,
		arg.Name,
		arg.Purpose,
		arg.ExtractedData,
	)
	return err
}

const insertSource = `-- name: InsertSource :exec
INSERT INTO SOURCE (
  ID, DESCRIPTION, CRAWLER, ROOT
) VALUES (
  ?, ?, ?, ?
)
`

type InsertSourceParams struct {
	ID          string
	Description string
	Crawler     string
	Root        string
}

func (q *Queries) InsertSource(ctx context.Context, arg InsertSourceParams) error {
	_, err := q.db.ExecContext(ctx, insertSource,
		arg.ID,
		arg.Description,
		arg.Crawler,
		arg.Root,
	)
	return err
}

const updateDocumentPurpose = `-- name: UpdateDocumentPurpose :exec
UPDATE DOCUMENT 
SET PURPOSE = ?
WHERE ID = ? AND SOURCE_ID = ?
`

type UpdateDocumentPurposeParams struct {
	Purpose  string
	ID       string
	SourceID string
}

func (q *Queries) UpdateDocumentPurpose(ctx context.Context, arg UpdateDocumentPurposeParams) error {
	_, err := q.db.ExecContext(ctx, updateDocumentPurpose, arg.Purpose, arg.ID, arg.SourceID)
	return err
}

const updateSectionPurpose = `-- name: UpdateSectionPurpose :exec
UPDATE SECTION 
SET PURPOSE = ?
WHERE ID = ? AND DOCUMENT_ID = ? AND SOURCE_ID = ?
`

type UpdateSectionPurposeParams struct {
	Purpose    string
	ID         string
	DocumentID string
	SourceID   string
}

func (q *Queries) UpdateSectionPurpose(ctx context.Context, arg UpdateSectionPurposeParams) error {
	_, err := q.db.ExecContext(ctx, updateSectionPurpose,
		arg.Purpose,
		arg.ID,
		arg.DocumentID,
		arg.SourceID,
	)
	return err
}

const upsertDocumentTag = `-- name: UpsertDocumentTag :exec
INSERT INTO DOCUMENT_TAG (
  SOURCE_ID, DOCUMENT_ID, TAG_KEY, TAG_VALUE
) VALUES (
  ?, ?, ?, ?
) ON CONFLICT DO NOTHING
`

type UpsertDocumentTagParams struct {
	SourceID   string
	DocumentID string
	TagKey     string
	TagValue   string
}

func (q *Queries) UpsertDocumentTag(ctx context.Context, arg UpsertDocumentTagParams) error {
	_, err := q.db.ExecContext(ctx, upsertDocumentTag,
		arg.SourceID,
		arg.DocumentID,
		arg.TagKey,
		arg.TagValue,
	)
	return err
}

const upsertSectionTag = `-- name: UpsertSectionTag :exec
INSERT INTO SECTION_TAG (
  SOURCE_ID, DOCUMENT_ID, SECTION_ID, TAG_KEY, TAG_VALUE
) VALUES (
  ?, ?, ?, ?, ?
) ON CONFLICT DO NOTHING
`

type UpsertSectionTagParams struct {
	SourceID   string
	DocumentID string
	SectionID  string
	TagKey     string
	TagValue   string
}

func (q *Queries) UpsertSectionTag(ctx context.Context, arg UpsertSectionTagParams) error {
	_, err := q.db.ExecContext(ctx, upsertSectionTag,
		arg.SourceID,
		arg.DocumentID,
		arg.SectionID,
		arg.TagKey,
		arg.TagValue,
	)
	return err
}
