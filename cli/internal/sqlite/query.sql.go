// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlite

import (
	"context"
)

const getDocumentIDsForSource = `-- name: GetDocumentIDsForSource :many
SELECT
  ID
FROM
  DOCUMENT
WHERE
  SOURCE_ID = ?
`

func (q *Queries) GetDocumentIDsForSource(ctx context.Context, sourceID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDocumentIDsForSource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionIDsForSource = `-- name: GetSectionIDsForSource :many
SELECT
  ID, DOCUMENT_ID
FROM
  SECTION
WHERE
  SOURCE_ID = ?
`

type GetSectionIDsForSourceRow struct {
	ID         string
	DocumentID string
}

func (q *Queries) GetSectionIDsForSource(ctx context.Context, sourceID string) ([]GetSectionIDsForSourceRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionIDsForSource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSectionIDsForSourceRow
	for rows.Next() {
		var i GetSectionIDsForSourceRow
		if err := rows.Scan(&i.ID, &i.DocumentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDocument = `-- name: InsertDocument :exec
INSERT INTO DOCUMENT (
  ID, SOURCE_ID, TYPE, PURPOSE, RAW_DATA, EXTRACTED_DATA
) VALUES (
  ?, ?, ?, ?, ?, ?
)
`

type InsertDocumentParams struct {
	ID            string
	SourceID      string
	Type          string
	Purpose       string
	RawData       string
	ExtractedData string
}

func (q *Queries) InsertDocument(ctx context.Context, arg InsertDocumentParams) error {
	_, err := q.db.ExecContext(ctx, insertDocument,
		arg.ID,
		arg.SourceID,
		arg.Type,
		arg.Purpose,
		arg.RawData,
		arg.ExtractedData,
	)
	return err
}

const insertSection = `-- name: InsertSection :exec
INSERT INTO SECTION (
  ID, DOCUMENT_ID, SOURCE_ID, PARENT_ID, PEER_ORDER, NAME, PURPOSE, EXTRACTED_DATA
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?
)
`

type InsertSectionParams struct {
	ID            string
	DocumentID    string
	SourceID      string
	ParentID      string
	PeerOrder     interface{}
	Name          string
	Purpose       string
	ExtractedData string
}

func (q *Queries) InsertSection(ctx context.Context, arg InsertSectionParams) error {
	_, err := q.db.ExecContext(ctx, insertSection,
		arg.ID,
		arg.DocumentID,
		arg.SourceID,
		arg.ParentID,
		arg.PeerOrder,
		arg.Name,
		arg.Purpose,
		arg.ExtractedData,
	)
	return err
}

const insertSource = `-- name: InsertSource :exec
INSERT INTO SOURCE (
  ID, DESCRIPTION, CRAWLER, ROOT
) VALUES (
  ?, ?, ?, ?
)
`

type InsertSourceParams struct {
	ID          string
	Description string
	Crawler     string
	Root        string
}

func (q *Queries) InsertSource(ctx context.Context, arg InsertSourceParams) error {
	_, err := q.db.ExecContext(ctx, insertSource,
		arg.ID,
		arg.Description,
		arg.Crawler,
		arg.Root,
	)
	return err
}

const updateDocumentPurpose = `-- name: UpdateDocumentPurpose :exec
UPDATE DOCUMENT 
SET PURPOSE = ?
WHERE ID = ? AND SOURCE_ID = ?
`

type UpdateDocumentPurposeParams struct {
	Purpose  string
	ID       string
	SourceID string
}

func (q *Queries) UpdateDocumentPurpose(ctx context.Context, arg UpdateDocumentPurposeParams) error {
	_, err := q.db.ExecContext(ctx, updateDocumentPurpose, arg.Purpose, arg.ID, arg.SourceID)
	return err
}

const updateSectionPurpose = `-- name: UpdateSectionPurpose :exec
UPDATE SECTION 
SET PURPOSE = ?
WHERE ID = ? AND DOCUMENT_ID = ? AND SOURCE_ID = ?
`

type UpdateSectionPurposeParams struct {
	Purpose    string
	ID         string
	DocumentID string
	SourceID   string
}

func (q *Queries) UpdateSectionPurpose(ctx context.Context, arg UpdateSectionPurposeParams) error {
	_, err := q.db.ExecContext(ctx, updateSectionPurpose,
		arg.Purpose,
		arg.ID,
		arg.DocumentID,
		arg.SourceID,
	)
	return err
}

const upsertDocumentTag = `-- name: UpsertDocumentTag :exec
INSERT INTO DOCUMENT_TAG (
  SOURCE_ID, DOCUMENT_ID, TAG_KEY, TAG_VALUE
) VALUES (
  ?, ?, ?, ?
) ON CONFLICT DO NOTHING
`

type UpsertDocumentTagParams struct {
	SourceID   string
	DocumentID string
	TagKey     string
	TagValue   string
}

func (q *Queries) UpsertDocumentTag(ctx context.Context, arg UpsertDocumentTagParams) error {
	_, err := q.db.ExecContext(ctx, upsertDocumentTag,
		arg.SourceID,
		arg.DocumentID,
		arg.TagKey,
		arg.TagValue,
	)
	return err
}

const upsertSectionTag = `-- name: UpsertSectionTag :exec
INSERT INTO SECTION_TAG (
  SOURCE_ID, DOCUMENT_ID, SECTION_ID, TAG_KEY, TAG_VALUE
) VALUES (
  ?, ?, ?, ?, ?
) ON CONFLICT DO NOTHING
`

type UpsertSectionTagParams struct {
	SourceID   string
	DocumentID string
	SectionID  string
	TagKey     string
	TagValue   string
}

func (q *Queries) UpsertSectionTag(ctx context.Context, arg UpsertSectionTagParams) error {
	_, err := q.db.ExecContext(ctx, upsertSectionTag,
		arg.SourceID,
		arg.DocumentID,
		arg.SectionID,
		arg.TagKey,
		arg.TagValue,
	)
	return err
}
