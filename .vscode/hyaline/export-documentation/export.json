[
  {
    "source": "hyaline",
    "document": "www/content/about.md",
    "uri": "document://hyaline/www/content/about.md",
    "content": "---\ntitle: About Hyaline\npurpose: Provide an overview of Hyaline and its purpose\n---\n\n# About Hyaline\n\n## What is Hyaline?\n\nHyaline is a documentation maintenance tool that helps software development teams keep their documentation current, accurate, and accessible. It automatically identifies when code changes require documentation updates, verifies that documentation match their intended purpose, and provides seamless integration with AI development workflows.\n\nKey capabilities include:\n\n- **Automated change detection**: Analyzes code diffs to identify documentation that needs updates\n- **Purpose validation**: Ensures your documentation actually serves its stated goals\n- **AI-ready data extraction**: Makes your documentation easily accessible to AI assistants through our MCP (Model Context Protocol) server\n- **Multi-source integration**: Pulls documentation from repositories, wikis, and documentation sites into a unified view\n\nWhether you're working with Claude, GitHub Copilot, or other AI tools, Hyaline ensures they have access to your latest, most accurate documentation to help you build better software faster.\n\n## Who Built Hyaline?\n\nHyaline is developed by [App Garden Studios](https://www.appgardenstudios.com/), a team of seasoned software engineers and technical leaders with decades of combined experience across startups and enterprise organizations. We've architected systems, led engineering teams, and experienced firsthand the productivity costs of outdated documentation.\n\nOur team understands the technical challenges of maintaining documentation at scale, from monorepos to distributed microservices, and we've built Hyaline to solve these problems systematically.\n\n## Our Vision for Hyaline\n\nWe're building the documentation tooling that modern development teams need. As AI becomes increasingly integrated into development workflows, having well-structured, accessible documentation becomes critical. Hyaline bridges this gap by:\n\n- Enabling you to use your documentation regardless of where it's located\n- Ensuring AI tools can access and utilize your documentation effectively\n- Verifying that critical documentation exists and covers what your team actually needs\n- Keeping documentation current so your documentation remain a reliable source of truth\n\nDocumentation should be a force multiplier for your team, not a maintenance overhead.\n\n## How Do You Pronounce Hyaline?\n\nWe pronounce it \"HIGH-uh-leen\" – meaning clear and transparent, just like we want your documentation to be.\n\n## Get in Touch\n\nReady to streamline your documentation workflow? Have technical questions about integration?\n\n**Contact us**: [john@hyaline.dev](mailto:john@hyaline.dev)",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/_index.md",
    "uri": "document://hyaline/www/content/documentation/_index.md",
    "content": "---\ntitle: \"Documentation\"\ndescription: \"Documentation to understand and use Hyaline effectively\"\n---",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/explanation/audit.md",
    "uri": "document://hyaline/www/content/documentation/explanation/audit.md",
    "content": "---\ntitle: \"Explanation: Audit\"\ndescription: Learn how Hyaline audits documentation for compliance with rules and checks\npurpose: Explain how Hyaline audits documentation against configurable rules to ensure compliance\n---\n## Overview\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Overview](./_img/hyaline-audit.svg)\n\nHyaline has the ability to audit your current set of documentation based on a set of rules and checks. Using Hyaline, you can ensure that your documentation contains the information necessary to comply with industry regulations or internal compliance rules. You can also check for consistency in documentation across all of your products and systems.\n\nIn this example, the current documentation (optionally filtered by specific sources) and the audit rules from your configuration file are provided as inputs to the audit command. The audit process evaluates each rule against the matching documentation. Hyaline uses an AI/LLM to perform qualitative checks, such as whether the documentation matches its intended purpose or a custom provided prompt.\n\nThe results of this audit, including the results of all checks that were preformed, are then output as a JSON file.\n\n\u003c/div\u003e\n\n## Rules\nHyaline uses audit rules defined in the configuration file to determine what documentation to audit and what checks to perform. You can define multiple rules, and each rule can target specific documentation using filters and apply multiple checks.\n\n\u003cdiv class=\"code-example\"\u003e\n\n```yml\naudit:\n  rules:\n    - id: \"content-exists-check\"\n      description: \"Check that content exists and has a purpose\"\n      documentation:\n        - source: \"**/*\"\n          document: \"README.md\"\n      ignore:\n        - source: \"internal\"\n      checks:\n        content:\n          exists: true\n          min-length: 100\n        purpose:\n          exists: true\n```\n\u003c/div\u003e\n\nIn the example above, the audit rule `content-exists-check` targets the `README.md` document for all sources except for `internal` and performs three checks: verify the content exists, ensure it meets a minimum length of 100 characters, and confirm a purpose is defined.\n\n## Checks\nHyaline supports several types of checks that can be applied to documentation. These checks fall into three categories: \"content checks\" for validating documentation structure and content, \"purpose checks\" for ensuring documentation purposes are correct, and \"tag checks\" for verifying documents and sections have the right tags.\n\n### Content Checks\nContent checks validate the existence, structure, and content of documentation.\n\n#### Content Exists\nVerifies that documentation matching the specified filters exists. This check is useful for ensuring required documentation is present.\n\n\u003cdiv class=\"code-example\"\u003e\n\n```yml\naudit:\n  rules:\n    - id: \"required-docs\"\n      description: \"Ensure critical docs exist\"\n      documentation:\n        - source: \"**/*\"\n          document: \"README.md\"\n      checks:\n        content:\n          exists: true\n```\n\n\u003c/div\u003e\n\nThis example checks that a README.md file exists in all sources. The check passes if at least one document matches the filters.\n\n#### Content Min Length\nValidates that documentation content meets a minimum length requirement in characters. This helps ensure documentation provides sufficient detail.\n\n\u003cdiv class=\"code-example\"\u003e\n\n```yml\naudit:\n  rules:\n    - id: \"sufficient-content\"\n      description: \"Ensure docs are detailed enough\"\n      documentation:\n        - source: \"api\"\n          document: \"**/*.md\"\n      checks:\n        content:\n          min-length: 500\n```\n\n\u003c/div\u003e\n\nThis example ensures all markdown files in the \"api\" source contain at least 500 characters. Documentation shorter than this will fail the check.\n\n#### Content Matches Regex\nValidates documentation content against a regular expression pattern. This is useful for ensuring specific information or formatting is present.\n\n\u003cdiv class=\"code-example\"\u003e\n\n```yml\naudit:\n  rules:\n    - id: \"installation-instructions\"\n      description: \"Ensure install steps are present\"\n      documentation:\n        - source: \"**/*\"\n          document: \"README.md\"\n      checks:\n        content:\n          matches-regex: \"(?i)(install|setup|getting.started)\"\n```\n\n\u003c/div\u003e\n\nThis example verifies that README files contain installation-related keywords (case-insensitive). Documentation that doesn't match the regex will fail the check.\n\n#### Content Matches Prompt\nUses an LLM to validate content against a custom prompt or criteria. This provides flexible validation for complex requirements that cannot be expressed with simple rules.\n\n\u003cdiv class=\"code-example\"\u003e\n\n```yml\naudit:\n  rules:\n    - id: \"security-guidelines\"\n      description: \"Ensure security best practices\"\n      documentation:\n        - source: \"security\"\n          document: \"**/*.md\"\n      checks:\n        content:\n          matches-prompt: \"Does this document contain specific security guidelines for handling user data?\"\n```\n\n\u003c/div\u003e\n\nThis example uses an LLM to evaluate whether security documentation adequately covers user data handling guidelines. The LLM provides a reason for its pass/fail decision.\n\n#### Content Matches Purpose\nUses an LLM to verify that documentation content aligns with its stated purpose. This ensures documentation actually serves its intended function.\n\n\u003cdiv class=\"code-example\"\u003e\n\n```yml\naudit:\n  rules:\n    - id: \"purpose-alignment\"\n      description: \"Ensure content matches purpose\"\n      documentation:\n        - source: \"**/*\"\n          document: \"**/*.md\"\n      checks:\n        content:\n          matches-purpose: true\n```\n\n\u003c/div\u003e\n\nThis example uses an LLM to verify that the actual content of each document aligns with its stated purpose. The LLM provides a reason for its pass/fail decision.\n\n### Purpose Checks\nPurpose checks ensure that documentation has a defined purpose. Purposes help ensure documentation serves a clear function and can be maintained effectively.\n\n#### Purpose Exists\nValidates that documentation has a defined purpose. \n\n\u003cdiv class=\"code-example\"\u003e\n\n```yml\naudit:\n  rules:\n    - id: \"documented-purposes\"\n      description: \"Ensure all docs have purposes\"\n      documentation:\n        - source: \"**/*\"\n          document: \"**/*.md\"\n      checks:\n        purpose:\n          exists: true\n```\n\n\u003c/div\u003e\n\nThis example ensures all markdown files have a defined purpose. Documentation without a purpose statement will fail this check.\n\n### Tag Checks\nTag checks validate the presence and values of metadata tags on documentation. Tags are used for categorization, compliance tracking, and filtering, making these checks essential for maintaining organized and compliant documentation.\n\n#### Tags Contains\nValidates that required tags are present on documentation. Tag keys and values can be specified as a regex pattern.\n\n\u003cdiv class=\"code-example\"\u003e\n\n```yml\naudit:\n  rules:\n    - id: \"compliance-tags\"\n      description: \"Ensure compliance metadata\"\n      documentation:\n        - source: \"**/*\"\n          document: \"**/*.md\"\n      checks:\n        tags:\n          contains:\n            - key: \"compliance\"\n              value: \"required\"\n            - key: \"reviewed\"\n              value: \"true\"\n```\n\n\u003c/div\u003e\n\nThis example verifies that documents have both a \"compliance: required\" tag and a \"reviewed: true\" tag. Both tags must be present for the check to pass.\n\n## Results\n\nOnce Hyaline completes the audit, it generates a JSON file containing detailed results for each rule and check. The results provide information about what passed, what failed, and why.\n\nFor detailed information about the results schema, see the [Audit Results Reference](../reference/audit-results.md).",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/explanation/check.md",
    "uri": "document://hyaline/www/content/documentation/explanation/check.md",
    "content": "---\ntitle: \"Explanation: Check\"\ndescription: Learn how Hyaline analyzes code changes to identify documentation that needs updating\npurpose: Explain how Hyaline checks for what documentation needs to be updated\n---\n## Overview\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Overview](./_img/check-overview.svg)\n\nHyaline has the ability to check code changes and recommend documentation updates based on the code that was updated. To support this process Hyaline utilizes several pieces of context and configuration to provide its recommendations.\n\n**Diff**: Hyaline examines the code that was changed and bases its documentation updates on these changes.\n\n**Current Documentation**: Hyaline uses the set of current documentation to determine which (if any) documents should be updated.\n\n**Pull Request and Issues**: Hyaline supports pulling in a pull request and one or more issues to provide additional context to the changes.\n\n**Config**: Hyaline uses information from the configuration file to determine which code and documentation to consider, as well as providing the ability to directly link code and documentation through updateIf statements.\n\n**AI/LLM**: Hyaline uses an LLM to help determine what documents should be updated for each code change by prompting it with the contents of the change, along with existing documentation and other related context.\n\nHyaline uses all of these resources to check either a diff (i.e. the difference between two branches of code) or the changes in a PR and determine which documents should be updated. It then formats the results of the check into a series of recommendations of which documents to examine and consider updating. Hyaline supports outputting recommendations as a JSON file (for `check pr` and `check diff` commands) as well as creating/updating a comment on the GitHub PR itself (only done on `check pr`).\n\n\u003c/div\u003e\n\n## Inputs\nThe following are context or resources used in the Check Process.\n\n### Diff\nHyaline uses each code file changed in a diff as an input to the recommendation process, and provides fine grained configuration that allows you to select only the relevant files to consider while excluding irrelevant files like tests or vendored dependencies.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```yml\ncheck:\n  code:\n    include:\n      - \"**/*.js\"\n      - \"package.json\"\n    exclude:\n      - \"old/**/*\"\n      - \"**/*.test.js\"\n  ...\n```\n\n![Code Diff](./_img/check-code-diff.svg)\n\n\u003c/div\u003e\n\nIn the example above we have a configuration that includes all `.js` files in the repository along with the `package.json` file at the root of the repository. We also exclude anything in the `old/` directory along with any test files ending with `.test.js`. Using this configuration Hyaline will examine any changes in the following files: `components/app.js`, `components/header.js`, `index.js`, and `package.json`. Note that `components/app.test.js` and `components/header.test.js` are excluded because they match the exclude glob `**/*.test.js`. Also notice that both `old/app.js` and `old/header.js` are excluded because they match the exclude glob `old/**/*`. As a final note, the file `package-lock.json` was not included because it does not match any of the include rules.\n\n\n### Current Documentation\nHyaline supports the ability to specify the set of documentation that should be considered when determining what documentation may need to be updated. This can be helpful in large organizations where a particular repository only affects a single system out of many, and narrowing the set of documentation considered can provide significant speed and cost savings.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```yml\ncheck:\n  ...\n  documentation:\n    include:\n      - source: \"**/*\"\n    exclude:\n      - source: infra\n        document: docs/old-*\n      - source: my-app\n        document: CHANGELOG.md\n  ...\n```\n\n![Documentation](./_img/check-documentation.svg)\n\n\u003c/div\u003e\n\nIn the example above we have a configuration that includes all documentation sources, meaning Hyaline will check for needed documentation updates across all sources in the current documentation data set. It also excludes 2 sets of documentation: any documents in the `infra` source in the `docs/` folder that start with `old-` and the document `CHANGELOG.md` in the `my-app` source. Using this configuration Hyaline will consider all available documentation except `docs/old-cluster.md` (because it matched the first exclude statement) and `CHANGELOG.md` (because it matched the second statement).\n\n### Pull Request and Issues\nHyaline supports the ability to include context from a GitHub pull request and one or more issues when determining what set of documentation may need to be updated based on a change. This can be helpful as pull requests and issues can include notes or requirements stating documentation that should be updated.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```bash\n$ hyaline check diff /\n  ...\n  --pull-request /\n    appgardenstudios/hyaline-example/7 /\n  --issue /\n    appgardenstudios/hyaline-example/4 /\n  --issue /\n    appgardenstudios/hyaline-example/5 /\n  ...\n```\n\n![PR and Issue Context](./_img/check-pr-and-issues.svg)\n\n\u003c/div\u003e\n\nIn the example above we have the hyaline command `check diff` that is passing in a pull request and two issues. The image on the right lists the available issues and pull requests in the `appgardenstudios/hyaline-example` repo on GitHub. Hyaline will pull in the titles and bodies of `Pull Request #7` and `Issues #4` and `#5` and add them to the LLM's prompt context when considering the set of documentation that may need to be updated.\n\n### UpdateIf Rules\nHyaline supports the ability to link code directly to relevant documentation via configuration. This linking is done by specifying an updateIf condition, where if certain code is updated then a set of documentation should also be updated. This can help in instances where changes to certain files (like routes or security rules) always need to be reflected in other documentation. Hyaline supports specifying that documentation needs to be updated if files are touched, added, modified, deleted, or renamed.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```yaml\ncheck:\n  options:\n    updateIf:\n      touched:\n        - code:\n            path: \"src/routes.js\"\n          documentation:\n            source: \"my-app\"\n            document: \"docs/routes.md\"\n```\n\n![UpdateIf Rules](./_img/check-updateif.svg)\n\n\u003c/div\u003e\n\nIn the example above we have a configuration that specifies the document `docs/routes.md` should be updated any time the file `src/routes.js` is touched. Note that the documentation does not need to be in the same repository/source as the code being checked, allowing you to keep disparate documentation in sync. when Hyaline checks for which documentation may need to be updated it detects changes to the file `src/routes.js` and adds the document `docs/routes.md` in the source `my-app` to the list of recommended updates with a reason referencing the configured updateIf statement.\n\n### LLM Prompt\nHyaline prompts an LLM to determine which pieces of documentation (if any) should be updated for a specific code change. Hyaline provides the code change, a list of document and sections (along with their purpose if available), and the pull request and issues (if provided) to the LLM to help it determine which documents and/or sections should be updated.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```diff\n--- src/server.js\n+++ src/server.js\n@@ -15,6 +15,9 @@ function serve() {\n }\n \n function isValidUrl(string) {\n+  if (!string) {\n+    return false;\n+  }\n   try {\n     new URL(string);\n     return true;\n```\n\n![LLM Prompt](./_img/check-prompt.svg)\n\n\u003c/div\u003e\n\nIn the example above we have a code file diff under examination. Hyaline provides the diff, a list of documents and sections, the pull request, and any issues provided to the LLM as context for the prompt. Then the prompt asks the LLM to use the documentation, diff, and other context to determine what documentation (if any) should be updated.\n\n## Check Process\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Check Process](./_img/check-process.svg)\n\nWhen Hyaline performs a check on a diff or PR it collects all of the relevant context it needs, such as the list of code files that have changed and are in scope, the set of documentation to consider, and the contents of a pull request or issues. Once collected, Hyaline checks for needed documentation updates in a 3 step process:\n\n**1: Check each Changed File** - Hyaline loops through each changed file in the diff and evaluates it to see what documentation may need to be updated. It makes a single call to an LLM passing in context and prompting it to respond with a list of documents and/or sections that may need to be updated along with the reason why. It also looks at the configuration file to see if there are any updateIf statements that apply to the changed file. The resulting set of documents and sections that may require updates is then returned.\n\n**2: Collate the Results** - Hyaline then takes the set of documents and sections that may require updates, along with the reason(s) provided, and collates them into a single unified set of recommendations. This set  of recommendations contains a sorted list of documents and sections with the reason(s) they may need to be updated attached to each document or section.\n\n**3: Check for Documentation Changes** - Once the set of recommendations is collated Hyaline scans the diff and updates the recommendations to mark any documents that have been changed as a part of the diff. Note that this step is only done if Hyaline is configured to do so. For more information on configuring Hyaline to detect and mark changed documents please see the configuration option `detectDocumentationUpdates` in the [configuration reference](../reference/config.md).\n\n\u003c/div\u003e\n\n\n## Recommendations\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Recommendations](./_img/check-recommendations.svg)\n\nOnce Hyaline has generated a set of recommendations they can either be output as a JSON file (using the `--output` option) or added as a comment to the pull request (only available for `hyaline check pr`).\n\nFor `hyaline check pr`, the `--output` option outputs the combined recommendations of the current run and previous run (if there is one). This is the same set of recommendations that is added as a comment to the pull request. In order to output the recommendations from the current `hyaline check pr` run, you can provide the `--output-current` option. Similarly, the previous recommendations can be output by providing the `--output-previous` option.\n\nThe schema for the recommendations output can be viewed [here](../reference/recommendations.md).\n\nThe comment on the pull request contains the following:\n\n- The Git SHA of the commit that was compared\n- A list of recommendations where each one has:\n  - A checkbox used to indicate that the recommendation for the document/section has been addressed\n  - The name of the document (and section if applicable)\n  - The documentation source name\n  - The list of reasons the documentation should be updated\n\n\u003c/div\u003e\n\n### Pull Request Comment Updates\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Screenshot of a Pull Request Comment](_img/check-pr-comment.png)\n\nIf `hyaline check pr` is run more than once for the same PR, Hyaline will update the previous comment instead of creating a new one. This ensures that the comment from Hyaline always stays up-to-date with the latest changes. When updating Hyaline merges the original set of recommendations with the new set as follows:\n\n1. Any original recommendation for a document or section that does not have a corresponding match in the new set is copied over as is.\n2. Any new recommendation for a document or section that does not have a corresponding match in the original set is used as is.\n3. Any original recommendation for a document or section that does have a match in the new set is merged, and the new set of reasons is appended to the original set of reasons before being used.\n4. The final set of recommendations is sorted by source, document, and section\n\nNote that the state of the checkboxes are preserved, allowing you to track which recommendations have been addressed. Hyaline will automatically check the box if it detects that the document has been updated as a part of the PR (provided it is configured to perform that check).\n\n\u003c/div\u003e",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/explanation/extract.md",
    "uri": "document://hyaline/www/content/documentation/explanation/extract.md",
    "content": "---\ntitle: \"Explanation: Extract\"\ndescription: Learn how Hyaline extracts documentation from various sources into a unified current data set\npurpose: Explain how Hyaline extracts documentation\n---\n## Overview\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Overview](./_img/extract-documentation-overview.svg)\n\nHyaline has the ability to extract documentation into a current data set that can be used to build systems and products as well as verify that the documentation is accurate and complete.\n\nIn this example you can see documentation spread over multiple repositories and documentation sites. Hyaline can extract this documentation into a current [documentation data set](../reference/data-set.md) and make it available for use.\n\nThis documentation data set can be used in many different ways. Documentation can be [merged](./merge.md) together into a unified documentation set or used to [check](./check.md) and [audit](./audit.md) the extracted documentation. It can also be used via an [MCP server](./mcp.md) or by the organization for a variety of other purposes. \n\nEach repository or documentation site is considered a documentation source, or source for short. All of the documentation in a source is crawled and extracted in a single pass, and then tagged and enhanced with additional metadata. Hyaline supports a number of different crawlers and extractors to make sure you can get all of your documentation extracted and available for use.\n\n\u003c/div\u003e\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Extract Phases](./_img/extract-documentation-phases.svg)\n\nExtracting documentation is broken up into 3 distinct phases: **Crawl**, **Extract**, and **Add Metadata**.\n\n**Crawl** is where Hyaline starts in a particular directory, repository, or website and scans it for available documentation. Each document it finds is saved off and passed to an appropriate extractor.\n\n**Extract** is where Hyaline takes the raw document that was crawled and extracts documentation from it. Because Hyaline deals in markdown documentation, any document that is in another format is converted into markdown and stored. Once converted to markdown (if needed), Hyaline stores the document and sections in a current data set.\n\n**Add Metadata** is where Hyaline applies additional metadata, like tags and purposes, to extracted documents and sections. This allows you to explicitly categorize and enhance the extracted documentation with information that is useful when checking, auditing, reading, or otherwise using the documentation.\n\n\u003c/div\u003e\n\n## Crawling Documentation\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Crawling Documentation](./_img/extract-documentation-crawling.svg)\n\nHyaline can be configured to crawl a documentation source and extract documentation. Hyaline supports a number of different crawlers, each with their own capabilities and configuration.\n\n- **fs** - The file system crawler looks for documentation on a local filesystem.\n- **git** - The git crawler looks for documentation on a specific branch or reference of a git repository.\n- **http** - The http crawler looks for documentation on a local or remote http or https server.\n\nRead more about each of these extractors and how they operate below.\n\n\u003c/div\u003e\n\n### Crawling Documentation - fs\n\nThe `fs` crawler crawls a local filesystem starting at a path, and processes each document it encounters.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```yml\nextract:\n  ...\n  crawler:\n    type: fs\n    options:\n      path: ./my-app\n    include:\n      - \"**/*.md\"\n    exclude:\n      - \"old/**/*\"\n      - \"LICENSE.md\"\n  ...\n```\n\n![Crawling Documentation - fs](./_img/extract-documentation-fs.svg)\n\n\u003c/div\u003e\n\nIn this example you can see that Hyaline is configured to start crawling in the `./my-app` directory and process any documents that match `**/*.md`. Hyaline processes all of the markdown documents in the `contributing/` directory and `src/` directory. Hyaline does not process the markdown file in the `old/` directory as everything in that directory is excluded. Hyaline also processes the `README.md` file at the root of the path but does not process the `License.md` file as that file is excluded.\n\n### Crawling Documentation - git\n\nThe `git` crawler crawls a git repository starting at its root, and processes each document it encounters.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```yml\nextract:\n  ...\n  crawler:\n    type: git\n    options:\n      repo: git@github.com:o/my-app.git\n      clone: true\n      branch: main\n    include:\n      - \"**/*.md\"\n    exclude:\n      - \"internal/old.md\"\n      - \"releases/2021*\"\n  ...\n```\n\n![Crawling Documentation - git](./_img/extract-documentation-git.svg)\n\n\u003c/div\u003e\n\nIn this example you can see that Hyaline is configured to clone the remote repo `git@github.com:o/my-app.git` into memory and process any documents on branch `main` that match `**/*.md`. Hyaline processes the documents `cmd/env.md`, `internal/arch.md`, and `README.md` as they match the include. It does not process `internal/old.md` as that document is explicitly excluded. It also only processes documents in the release directory that do not start with `2021` as those document are excluded.\n\n### Crawling Documentation - http\n\nThe `http` crawler crawls an HTTP or HTTPS website starting at a configured starting url, and processes each document it encounters.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```yml\nextract:\n  ...\n  crawler:\n    type: http\n    options:\n      baseUrl: https://my-app.com/docs/\n    include:\n      - \"**/*\"\n    exclude:\n      - \"roadmap\"\n  ...\n```\n\n![Crawling Documentation - http](./_img/extract-documentation-http.svg)\n\n\u003c/div\u003e\n\nIn this example you can see that Hyaline calculates a starting url of `https://my-app.com/docs/` based off of the `baseUrl` and an optional `start` path (not shown here). Hyaline then starts crawling at `https://my-app.com/docs/` and processes any documents that match `**/*`. Note that the include and exclude glob matching is scoped to the `baseUrl`. Hyaline processes the linked documents in the `/docs/` directory with the exception of `/docs/roadmap` (which is excluded). Also note that even though the document `/docs/getting-started` links to `/contact`, `/contact` is not processed as it does not match any include statements.\n\nNote that Hyaline will not crawl outside of the specified domain, so you don't need to worry about it getting lost in the internet.\n\nAlso note that you can configure the `baseURL` independently of the starting URL. Please see the [extract config documentation](../reference/config.md) for more information.\n\n## Extracting Documentation\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Extracting Documentation](./_img/extract-documentation-extracting.svg)\n\nHyaline can be configured to extract documentation differently based on the type of documentation encountered. Hyaline supports a number of different extractors, each with their own capabilities and configuration.\n\n- **md** - The markdown extractor handles raw markdown documents\n- **html** - The html extractor converts html to markdown before extracting the document and section(s)\n\nNote that the first matching extractor is used for each document, allowing you to extract multiple different document formats from the same source in a single pass.\n\n\u003c/div\u003e\n\n### Extracting Documentation - md\n\nThe `markdown` extractor extracts markdown documents.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```yml\nextract:\n  ...\n  extractors:\n    - type: md\n      include:\n        - \"**/*.md\"\n  ...\n```\n\n![Extracting Documentation - md](./_img/extract-documentation-md.svg)\n\n\u003c/div\u003e\n\nIn this example you can see the markdown document being extracted into a document and its sections based on the configured extractor.\n\n\n### Extracting Documentation - html\n\nThe `html` extractor extracts html documents by extracting the content of the documentation and transforming it into markdown.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```yml\nextract:\n  ...\n  extractors:\n    - type: html\n      options:\n        selector: main\n      include:\n        - \"**/*\"\n  ...\n```\n\n![Extracting Documentation - html](./_img/extract-documentation-html.svg)\n\n\u003c/div\u003e\n\nIn this example you can see an html document being extracted into a document and its sections. Hyaline is configured to select just the html in the `main` tag, which is then transformed into markdown and stored as a document and sections.\n\n### A Note on Sections\n\nHyaline scans the markdown document and extracts any sections it encounters. It identifies each section by name, and preserves any section level hierarchy it finds when saving the sections to the data set.\n\nNote that when Hyaline stores the ID of the section it replaces any \"/\" characters with \"_\". Hyaline uses \"/\" when generating an ID for a sub-section, as the ID includes the name(s) of the parent sections as well as the name of the sub-section (e.g. `Section 1/Section 1.1`).\n\n## Adding Metadata\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Adding Metadata](./_img/extract-documentation-metadata.svg)\n\nHyaline can be configured to add tags and purposes to each document and section that is extracted.\n\n**Tags** are key-value pairs that can be associated with a document or section and then used for filtering and retrieval when checking, referencing, or otherwise using the documentation.\n\n**Purpose** is the declared purpose of the document. It is used when checking which documentation needs to be updated for a particular code change, as it is typically a better indicator of what the document or section is intended to contain as compared to the contents itself (which may be out of date, incomplete, or entirely absent).\n\n\u003c/div\u003e\n\n### Adding Metadata - Purpose\n\nPurpose can be added to each matching document and/or section for later use.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```yml\nextract:\n  ...\n  metadata:\n    - document: \"Document 1\"\n      purpose: ABC\n    - document: \"Document 2\"\n      section: \"Section 1\"\n      purpose: XYZ\n  ...\n```\n\n![Adding Metadata - Purpose](./_img/extract-documentation-purpose.svg)\n\n\u003c/div\u003e\n\nIn this example you can see a set of documents that have been extracted. Based on the configuration `Document 1` has its purpose set to `ABC`, and `Document 2 \u003e Section 1` has its purpose set to `XYZ`.\n\n### Adding Metadata - Tags\n\nTags can be added to each matching document and/or section for later use.\n\n\u003cdiv class=\"side-by-side\"\u003e\n\n```yml\nextract:\n  ...\n  metadata:\n    - document: \"**/*\"\n      tags:\n        - key: system\n          value: my-app\n    - document: \"Document 1\"\n      section: \"Section 2\"\n      tags:\n        - key: component\n          value: fe\n  ...\n```\n\n![Adding Metadata - Tags](./_img/extract-documentation-tags.svg)\n\n\u003c/div\u003e\n\nIn this example you can see a document that have been extracted. Based on the configuration `Document 1` has the tag `system` set to `my-app`, and `Document 1 \u003e Section 2` has the tag `component` set to `fe`. Note that you can set as many tags on each document and/or section as you wish.\n\n## Next Steps\nRead on about how [checking documentation](./check.md) works, or visit the [configuration reference documentation](../reference/config.md) to see how to configure Hyaline to extract your documentation.",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/explanation/hyaline.md",
    "uri": "document://hyaline/www/content/documentation/explanation/hyaline.md",
    "content": "---\ntitle: \"Explanation: Hyaline\"\ndescription: Learn about Hyaline's architecture, workflow, and how it helps teams maintain documentation alongside their code\npurpose: Explain the overall data flow and architecture of Hyaline\n---\n## Introduction\nHyaline is intended to help software development teams use their documentation to build and maintain their products. To that end Hyaline has two primary objectives: 1) help teams create, update, and maintain their documentation so that they can 2) use their documentation to create, maintain, and ship their products.\n\n## Use Cases\nTo help you understand a bit more about what Hyaline does and does not do, consider the following:\n\n**Use cases that Hyaline is intended to support**:\n* Identify documentation that needs to be updated when a software change is implemented - Hyaline can examine your code changes and help identify what documentation needs to be updated and why\n* Identify documentation that does not match its intended purpose or is incomplete - Hyaline can scan your existing documentation and ensure that each document and section matches your intended purpose and is complete.\n* Ensure that certain documentation, including documentation that is required for regulatory or compliance purposes, is consistently created and maintained - Hyaline can be configured to use centralized rules to ensure certain documentation is present and updated across all of your products and systems.\n* Allow an LLM to scan, search, and use your documentation to help you build your product(s) - Hyaline extracts and indexes all of your documentation, and makes that information available through an [MCP server](./mcp.md).\n\n**Use cases that Hyaline is not intended to support**:\n* Creating and/or updating documentation without human involvement - Hyaline is intended to _augment_ team members, not replace them.\n* Extracting or storing 3rd party documentation such as API/Library documentation.\n\n## Workflow\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Workflow](./_img/hyaline-workflow.svg)\n\nIn this workflow people, assisted by AI, build products and systems. While doing so they create and update documentation. That documentation is then read and used by people to build products and systems, and the cycle continues. Hyaline sits in between people/AI and documentation, and is intended to assist in both creating/updating documentation and reading/using documentation to build products and systems.\n\n\u003c/div\u003e\n\n## Extract\n\u003cdiv class=\"portrait\"\u003e\n\n![Extract](./_img/hyaline-extract.svg)\n\nHyaline has the ability to [extract documentation](./extract.md) from many different types of repositories and documentation sites. It supports extracting from local file systems, local or remote git repositories, and HTTP or HTTPS websites.\n\nEach set of extracted documentation is considered a documentation source, and is stored by Hyaline in [an SQLite database](../reference/data-set.md). You can extract and store as many documentation sources as you wish, and each documentation source can be assigned metadata and tagged during the extraction process. Hyaline also separates out sections within a document, letting you be granular when using or updating each piece of documentation. \n\nThis extracted documentation can be [merged](merge.md) into a single current documentation data set and used for a variety of purposes including: [checking code changes](./check.md) to determine what documentation may need to be updated, [auditing](./audit.md) the organization's documentation for compliance with regulations or internal processes, or using the documentation to develop products and systems via an [MCP server](./mcp.md).\n\nHowever it is used, the documentation extracted by Hyaline helps you both use your documentation and keep it up to date.\n\n\u003c/div\u003e\n\n## Check\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Check](./_img/hyaline-check.svg)\n\nHyaline has the ability to [check](./check.md) code changes and recommend documentation updates based on the code that was updated. To support this process Hyaline utilizes several resources to provide recommendations:\n\n**Code Diffs**: Hyaline examines each piece of code that was changed to determine what documentation may need to be updated based on each change.\n\n**Current Documentation**: Hyaline uses the entire set of current documentation when determining which documentation may need to be updated for a code change.\n\n**Pull Request and Issues**: Hyaline can pull in a pull request and one or more issues to provide additional context when evaluating potential documentation updates.\n\n**Configuration**: Hyaline provides fine-grained control over what code and documentation to consider, and provides the ability to directly link code to relevant documentation using “Update If” statements.\n\n**AI/LLMs**: Hyaline uses an LLM to help determine what documents should be updated for each code change. This information goes from you to your configured LLM directly, and we do not see or process your code or documentation in any way.\n\nHyaline supports checking the difference between two local branches or the code changes in a PR. It can be configured to run locally or in a CI process such as GitHub Actions to provide critical insight into what documentation may need to be updated across your organization.\n\nHowever you choose to configure Hyaline, it helps you keep your documentation accurate and up-to-date.\n\n\u003c/div\u003e\n\n## Audit\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Audit](./_img/hyaline-audit.svg)\n\nHyaline has the ability to audit your current set of documentation based on a set of rules and checks. Using Hyaline, you can ensure that your documentation contains the information necessary to comply with industry regulations or internal compliance rules. You can also check for consistency in documentation across all of your products and systems.\n\nIt is up to you to decide what and when to audit, but when you do Hyaline is there to help.\n\n\u003c/div\u003e\n\n## MCP\n\n\u003cdiv class=\"portrait\"\u003e\n\n![MCP](./_img/hyaline-mcp.svg)\n\nHyaline comes with a built-in MCP server that makes your documentation available to LLM models via the [Model Context Protocol](https://modelcontextprotocol.io/) (MCP). MCP is a standardized mechanism to provide LLMs and AI systems the context they need to do their job.\n\nTo use Hyaline's MCP server you first use Hyaline to [extract](./extract.md) and [merge](./merge.md) all of your organization's documentation into a documentation data set. Once complete, you then install Hyaline’s MCP server in your host of choice (i.e. Claude Desktop) and configure Hyaline to use your current documentation data set. Once installed, your AI assistant has the ability to list and retrieve all of your organization's documentation. Then, when you ask your LLM to complete a task that requires documentation, your LLM can use the tools exposed by Hyaline's MCP server to list and retrieve relevant documentation.\n\nRegardless of the type of documentation your organization maintains, Hyaline can help you use that documentation when leveraging AIs and LLMs to help build products and systems.\n\n\u003c/div\u003e\n\n## Next Steps\nContinue reading about various Hyaline concepts such as [extract](./extract.md), or get started by visiting [getting started](../getting-started.md).",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/explanation/mcp.md",
    "uri": "document://hyaline/www/content/documentation/explanation/mcp.md",
    "content": "---\ntitle: \"Explanation: MCP\"\ndescription: Learn how Hyaline's MCP server provides documentation access to LLMs\npurpose: Explain how Hyaline's MCP server works\n---\n## Overview\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Overview](_img/mcp-overview.svg)\n\nHyaline has a built-in MCP server that can make your documentation available to LLM models via the [Model Context Protocol](https://modelcontextprotocol.io/introduction) (MCP). First, you use Hyaline to [extract](./extract.md) all of your documentation into a documentation data set. This data set is stored in an SQLite database and can be sent, shared, or used independently of Hyaline if you wish. The data set can also be [merged](./merge.md) with other data sets to combine documentation from multiple sources. Once the documentation data set is complete, you install Hyaline's MCP server in your host of choice (i.e. Claude Desktop) and point Hyaline to that data set. Once configured, your AI assistant will have the ability to list and retrieve all of your documentation that is stored in your documentation data set. Then, when you ask your LLM to complete a task that requires documentation, your LLM can use the tools exposed by the MCP server via the host to list and retrieve relevant documentation.\n\nPlease visit the [MCP reference](../reference/mcp.md) for more detailed information on the tools made available by the MCP server.\n\n\u003c/div\u003e\n\n## Concepts\n\n### Organization\n\nHyaline extracts and stores documentation organized by documentation sources. For example, the documentation sources could include 1) the development oriented documentation checked into the repository alongside the code (README and other markdown files), 2) operations oriented documentation stored in an internal wiki, 3) customer focused documentation stored on a website, etc...\n\nInside each documentation source is a set of documents. A document is either a single markdown file or html page that was discovered and saved during the extraction process. Additionally, Hyaline parses each document and extracts the section hierarchy, meaning that Hyaline can reference not just a specific document but also specific sections within the document.\n\n\u003cdiv class=\"portrait\"\u003e\n\n![URIs](_img/mcp-uri.svg)\n\n### URIs\n\nHyaline constructs a URI to identify each extracted document and section. The format of the URI is `document://\u003csource-id\u003e/\u003cdocument-id\u003e[#\u003csection\u003e]` and is constructed as follows:\n\n- `\u003csource-id\u003e` is the globally unique ID of the documentation source as defined when extraction took place\n- `\u003cdocument-id\u003e` is the relative path of the document from the root of the extraction and may contain one or more path delimiters\n- `\u003csection\u003e` is optional and contains the name of the section. For sub-sections, the name of each parent section is prepended and separated by `/` (e.g. `#section1/subsection2`)\n\n\u003c/div\u003e\n\n\u003cdiv class=\"portrait\"\u003e\n\n![URIs](_img/mcp-filtering.svg)\n\n### Filtering\n\nThe MCP server supports two types of filtering:\n\n#### Prefix Filtering\nWhen you provide a partial URI path, the server will return all documents that match the prefix. For example:\n- `document://product-docs` returns all documents in the \"product-docs\" source\n- `document://api-docs` returns all documents in the \"api-docs\" source\n\n#### Tag Filtering\nDocuments and sections can have tags associated with them. You can filter results by including query parameters in the URI:\n\n- **Multiple values for the same tag**: When you specify multiple comma-separated values for the same tag key (e.g., `?audience=user,admin`), documents that have ANY of those tag values will be included\n- **Multiple tags**: When you specify multiple different tags (e.g., `?audience=user,admin\u0026level=beginner`), documents must match at least one value for EACH tag to be included\n\nExample filtering URIs:\n- `document://product-docs?audience=user` - returns documents tagged with an \"audience\" of \"user\"\n- `document://product-docs?audience=user,admin` - returns documents tagged with an \"audience\" of either \"user\" OR \"admin\"\n- `document://product-docs?audience=user,admin\u0026level=beginner` - returns documents tagged with an audience of either \"user\" OR \"admin\" AND a level of \"beginner\"\n\n\u003c/div\u003e\n\n## Next Steps\nYou can go read the [MCP reference](../reference/mcp.md) to see details on the tools exposed by the MCP server, or go and view the [CLI reference](../reference/cli.md) to see how to run the MCP server.",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/explanation/merge.md",
    "uri": "document://hyaline/www/content/documentation/explanation/merge.md",
    "content": "---\ntitle: \"Explanation: Merge\"\ndescription: Learn how Hyaline merges multiple documentation data sets\npurpose: Explain how Hyaline merge documentation works\n---\n## Overview\n\nHyaline has the ability to merge documentation data sets together. This can be used to create a single data set containing all current documentation, or to merge newly extracted documentation into an existing data set.\n\nMerging happens at the source level. If a source being merged in does not yet exist in the data set, the source is pulled in wholesale. If a source being merged in already exists, the documents, sections, and tags from the new source completely replace the old source.\n\n## Example\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Example](./_img/merge-example.svg)\n\nIn this example, we have two input databases and want to merge them into a single output database. **Input 1** contains **Source 1** and **Source 2**, each with their own documents. **Input 2** contains **Source 2** and **Source 3**, where **Source 2** has multiple documents that were not present in **Source 2** from **Input 1**.\n\nWhen merging, Hyaline does the following:\n- **Source 1** exists only in **Input 1**, so it's copied entirely to the output\n- **Source 2** exists in both inputs, so the version from **Input 2** overwrites the version from **Input 1** (later inputs take precedence)\n- **Source 3** exists only in **Input 2**, so it's copied entirely to the output\n\nThe final output database contains all three sources: **Source 1** from **Input 1**, **Source 2** from **Input 2**, and **Source 3** from **Input 2**.\n\n\u003c/div\u003e",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/getting-started.md",
    "uri": "document://hyaline/www/content/documentation/getting-started.md",
    "content": "---\ntitle: \"Getting Started with Hyaline\"\ndescription: \"Quick guide to install Hyaline, create configuration, extract documentation, and set up an MCP integration.\"\npurpose: Document how to get started with Hyaline\n---\nWelcome to Hyaline (pronounced \"HIGH-uh-leen\"), a documentation tool that helps software development teams keep their documentation current, accurate, and accessible. This guide will walk you through setting up Hyaline and performing your first documentation extraction and check.\n\n## What You'll Learn\n\nIn this guide, you'll learn how to:\n- Install the Hyaline CLI\n- Create a basic configuration file\n- Extract your documentation\n- Set up the MCP server for AI integration\n\n## Prerequisites\n\n- **Operating System**: Linux (64-bit), macOS, or Windows (64-bit)\n- **Architecture**: AMD64 or ARM64 (ARM64 not available for Windows)\n- **Documentation Source**: A documentation source (e.g. git repo, filesystem directory, website)\n\n## Step 1: Install the Hyaline CLI\n\n### Download the Latest Release\n\n1. Visit the [Hyaline releases page](https://github.com/appgardenstudios/hyaline/releases)\n2. Download the appropriate binary for your system:\n   - **Linux AMD64**: `hyaline-linux-amd64.zip`\n   - **Linux ARM64**: `hyaline-linux-arm64.zip`\n   - **macOS AMD64**: `hyaline-darwin-amd64.zip`\n   - **macOS ARM64**: `hyaline-darwin-arm64.zip`\n   - **Windows AMD64**: `hyaline-windows-amd64.zip`\n\n### Install the Binary\n\n1. **Unzip the downloaded file**:\n   ```bash\n   $ unzip hyaline-*-*.zip\n   ```\n\n2. **Make the binary executable** (Linux/macOS only):\n   ```bash\n   $ chmod +x hyaline\n   ```\n\n3. **Move to your PATH** (optional but recommended):\n   ```bash\n   # Linux/macOS\n   $ sudo mv hyaline /usr/local/bin/\n\n   # Or add to your local bin directory\n   $ mv hyaline ~/bin/\n   ```\n\n4. **Verify the installation**:\n   ```bash\n   $ hyaline version\n   ```\n\nFor detailed installation instructions, see [How To: Install the CLI](./how-to/install-cli.md).\n\n## Step 2: Create a Configuration File\n\nCreate a `hyaline.yml` file in your project root. Here's basic configuration to extract documentation from a typical project that has a locally checked-out git repo and `main` branch:\n\n```yaml\nextract:\n  source:\n    id: my-app\n    description: My application documentation\n  crawler:\n    type: git\n    options:\n      path: .\n      branch: main\n    include:\n      - \"README.md\"\n      - \"docs/**/*.md\"\n      - \"**/*.md\"\n    exclude:\n      - \"node_modules/**/*\"\n      - \".git/**/*\"\n  extractors:\n    - type: md\n      include:\n        - \"**/*.md\"\n  metadata:\n    - document: README.md\n      purpose: Provide an overview of the project, installation instructions, and basic usage examples\n    - document: docs/installation.md\n      purpose: Detailed installation and setup instructions\n```\n\n### Configuration Breakdown\n\n- **extract**: Top-level key for extraction configuration\n- **source**: Metadata about the documentation source (id and description)\n- **crawler**: Specifies how to crawl the documentation (git repository in this case)\n- **extractors**: List of extractors to process documentation files (markdown in this case)\n- **metadata**: Define purposes for specific documents\n\nNote that the above configuration is for a simple example, but Hyaline can be configured to extract documentation from multiple systems and sources (e.g. websites, remote git repositories). For complete configuration options and details, see the [Configuration Reference](./reference/config.md).\n\n## Step 3: Extract Documentation\n\nNow let's extract your documentation into a data set (note that you will need to run this from the root of the documentation source):\n\n```bash\n$ hyaline extract documentation \\\n  --config ./hyaline.yml \\\n  --output ./documentation.db\n```\n\nThis command will:\n- Scan your repository for documentation files based on the configuration\n- Extract and process them according to the defined extractors\n- Store everything in a SQLite database (`documentation.db`)\n\nFor more details on how extraction works, see [Explanation: Extract](./explanation/extract.md).\n\n## Step 4: Set Up MCP Server\n\nTo make your documentation available to AI assistants like Claude:\n\n1. **Extract documentation** (if not already done):\n   ```bash\n   hyaline extract documentation --config ./hyaline.yml --output ./documentation.db\n   ```\n\n2. **Start the MCP server**:\n   ```bash\n   hyaline serve mcp --documentation ./documentation.db\n   ```\n\n3. **Configure your AI client** to use the MCP server. The exact steps depend on your client, but you'll typically need to add a server configuration that runs the command above.\n\nFor detailed MCP setup instructions, see [How To: Run the MCP Server](./how-to/run-mcp.md) and [MCP Reference](./reference/mcp.md).\n\n## Next Steps\nTo set up GitHub Actions for automatic PR checks visit [How To: Check a PR](./how-to/check-pr.md), or see the [CLI Reference](./reference/cli.md) for complete command documentation.",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/how-to/build-cli.md",
    "uri": "document://hyaline/www/content/documentation/how-to/build-cli.md",
    "content": "---\ntitle: \"How To: Build the Hyaline CLI\"\ndescription: \"Build the Hyaline CLI from source using Go toolchain for custom versions or architectures.\"\npurpose: Document how to build the Hyaline CLI\n---\n## Purpose\nBuild the hyaline cli locally or on a remote machine.\n\n## Prerequisite(s)\n* [Go Toolchain](https://go.dev/) (version 1.24+)\n\n## Steps\n\n### 1. Clone/Checkout Hyaline Repo\nEnsure that the [Hyaline Repository](https://github.com/appgardenstudios/hyaline) is cloned and checked out to the version you wish to build.\n\n### 2. Determine the Version\nHyaline uses the commit date and short hash to specify the version being build. This can be determined by running the following commands in the root of the repository with the desired commit checked out.\n\n```bash\n# Format: YYYY-MM-DD-HASH\nDATE=`git log -n1 --pretty='%cd' --date=format:'%Y-%m-%d'`\nHASH=`git rev-parse --short HEAD`\nVERSION=\"$DATE-$HASH\"\n```\n\n### 3. Run Go Build\nOnce the version is specified you can build hyaline using the following command (from the root of the repo):\n\n```bash\n$ go build -o ./dist/hyaline -ldflags=\"-X 'main.Version=$VERSION'\" ./cmd/hyaline.go\n```\n\nYou can specify the OS and architecture to use by setting the appropriate [GOOS/GOARCH environment variables](https://go.dev/doc/install/source#environment). For example, to build for the 64bit ARM version of MacOS:\n\n```bash\n$ GOOS=darwin GOARCH=arm64 go build -o ./dist/hyaline -ldflags=\"-X 'main.Version=$TAG'\" ./cmd/hyaline.go\n```\n\n### 4. Test Executable\nMake sure you test that the resulting executable was built sucessfully and at the right version by running:\n\n```bash\n$ ./hyaline version\n```\n\n## Next Steps\nVisit [CLI Reference](../reference/cli.md).",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/how-to/check-pr.md",
    "uri": "document://hyaline/www/content/documentation/how-to/check-pr.md",
    "content": "---\ntitle: \"How To: Check a PR using the Hyaline CLI\"\ndescription: \"Set up GitHub Actions to automatically check documentation in pull requests using Hyaline.\"\npurpose: How to check a PR using the Hyaline CLI\n---\n## Purpose\nUse hyaline to check a pull request in GitHub.\n\n## Prerequisite(s)\n* A repository on GitHub with [GitHub Actions](https://github.com/features/actions) available.\n\n## Steps\n\n### 1. Check In Hyaline Configuration\nCreate a Hyaline Configuration File with [extract](../reference/config.md#extract) and [check](../reference/config.md#check) configured, and check it into your GitHub repository.\n\nMake sure you don't check in any secrets, like the LLM Provider Key or the GitHub Token. Instead, setup the configuration to pull them from the environment.\n\nSee [config reference](../reference/config.md) for more information on creating a configuration file and referencing secrets.\n\n### 2. Set Up Secrets\nFor each environment variable used in the Hyaline configuration that references a secret, set that variable up to be pulled in as a [secret in GitHub](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions).\n\n### 3. Create Workflow File\nCreate a [GitHub Workflow](https://docs.github.com/en/actions/writing-workflows/quickstart) file to run when a pull request is updated. You can see an example file in the [GitHub Actions reference](../reference/github-actions.md).\n\nAlternatively you could set Hyaline up to be run [manually on dispatch](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/manually-running-a-workflow).\n\n## Next Steps\nVisit [Config Reference](../reference/config.md), [GitHub Actions Reference](../reference/github-actions.md), or [Check Explanation](../explanation/check.md).",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/how-to/install-cli.md",
    "uri": "document://hyaline/www/content/documentation/how-to/install-cli.md",
    "content": "---\ntitle: \"How To: Install the Hyaline CLI\"\ndescription: \"How to download, install, and set up the Hyaline CLI on Linux, macOS, or Windows.\"\npurpose: Document how to install the Hyaline CLI\n---\n## Purpose\nInstall the Hyaline CLI.\n\n## Prerequisite(s)\n* (none)\n\n## Steps\n\n### 1. Determine OS and Architecture\nBefore starting the installation process you need to determine your operating system and architecture. Hyaline supports 64-bit Linux (`linux`), MacOS (`darwin`), and Windows (`windows`) operating systems for either `amd64` or `arm64` architectures (`amd64` only for Windows).\n\n### 2. Download Binary\nYou can download the appropriate binary from the [Release Page](https://github.com/appgardenstudios/hyaline/releases) on GitHub. Just select the release you would like to use and get the link to the appropriate binary from the assets section.\n\nAlternatively you can use the following URL template: `https://github.com/appgardenstudios/hyaline/releases/download/{RELEASE}/hyaline-{OS}-{ARCH}.zip`.\n\n### 3. Unzip and Make Hyaline Executable\nDepending on your operating system you will need to do one or more of the following:\n\n* Unzip the downloaded executable\n* Make `hyaline` executable (if applicable)\n* Add `hyaline` to your PATH (if desired)\n\n## Next Steps\nVisit [How To Run the CLI](./run-cli.md) or the [CLI Reference](../reference/cli.md).",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/how-to/run-cli.md",
    "uri": "document://hyaline/www/content/documentation/how-to/run-cli.md",
    "content": "---\ntitle: \"How To: Run the Hyaline CLI\"\ndescription: \"Run the Hyaline CLI.\"\npurpose: Document how to run the Hyaline CLI\n---\n## Purpose\nRun the hyaline cli locally or on a remote machine.\n\n## Prerequisite(s)\n* [Install the CLI](./install-cli.md)\n\n## Steps\n\n### 1. Ensure CLI is Installed\nRun `hyaline version` to ensure that the Hyaline CLI is installed and working properly.\n\n### 2. Get Path to Config\nMost commands require a hyaline configuration file. You will need to pass the path of the file in as the value of the `--config` commandline parameter. Either locate or create that configuration file now. For more information on the format of the configuration file please see the [Hyaline Config Reference](../reference/config.md).\n\n### 3. Export Env Vars (optional)\nBased on the contents of the configuration file above there may be one or more environment variables that need to be set before running Hyaline. You can find these in the config by looking for references like `${MY_VAR}`, which specifies that Hyaline should use the value of the environment variable `MY_VAR` for that key in the config.\n\n### 4. Execute the Command\nNow you can execute the hyaline command, passing in all of the required and (optionally) optional parameters. Please see [CLI Reference](../reference/cli.md) for a full list of commands and their associated options.\n\n## Next Steps\nVisit [CLI Reference](../reference/cli.md) or [How to build the CLI](./build-cli.md).",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/how-to/run-mcp.md",
    "uri": "document://hyaline/www/content/documentation/how-to/run-mcp.md",
    "content": "---\ntitle: \"How To: Run the Hyaline MCP Server\"\ndescription: \"Configure and run the Hyaline MCP server to make documentation available to AI assistants.\"\npurpose: Document how to run the Hyaline MCP Server\n---\n## Purpose\nRun the hyaline mcp server locally.\n\n## Prerequisite(s)\n* [Install the CLI](./install-cli.md)\n\n## Steps\n\n### 1. Ensure CLI is Installed\nRun `hyaline version` to ensure that the Hyaline CLI is installed and working properly.\n\n### 2. Extract Documentation\nRun `hyaline extract documentation` for each system you want to include. If you have multiple systems you can combine them into a single data set using `hyaline merge documentation`.\n\nPlace the resulting data set in a convenient location.\n\n### 3. Add MCP Server to Client\nThis will vary by client, but the gist of it is you want to have the client run the command `hyaline serve mcp --documentation ./path/to/documentation-data-set.db` to start a local MCP server listening over stdio.\n\nPlease see your client documentation for specific steps.\n\n## Next Steps\nVisit the [CLI Reference](../reference/cli.md).",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/overview.md",
    "uri": "document://hyaline/www/content/documentation/overview.md",
    "content": "---\ntitle: Overview\ndescription: \"Learn how Hyaline helps teams maintain documentation to build software products effectively.\"\npurpose: Give an overview of Hyaline and the documentation\n---\nHyaline is a tool that serves 2 primary purposes: 1) updating and maintaining documentation so that 2) documentation can be used to help build software products and systems. This body of documentation is intended to help you understand how Hyaline works and how to use Hyaline.\n\n## Structure\nThis documentation follows the concepts of [Diátaxis](https://diataxis.fr/) and is structured as follows:\n\n* How To - A series of how to guides showing how to accomplish several common goals\n* Explanation - A series of documents explaining various concepts within Hyaline, including a general overview of how each Hyaline command works\n* Reference - Detailed reference documentation for the various commands, options, and architectural elements of Hyaline\n* Roadmap - A high-level overview of the current and future focus of Hyaline's development\n\n## Next Steps\nTo learn how to get started and install Hyaline please visit [Getting Started](./getting-started.md)\n\nFor an in depth explanation of Hyaline itself please visit the [Explanation of Hyaline](./explanation/hyaline.md)\n\nFor a reference guide to the CLI please visit the [CLI Reference](./reference/cli.md)",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/reference/audit-results.md",
    "uri": "document://hyaline/www/content/documentation/reference/audit-results.md",
    "content": "---\ntitle: \"Reference: Audit Results\"\ndescription: JSON output format for results produced by the audit documentation command\npurpose: Detail the JSON output format for results produced by the audit documentation command\n---\n## Overview\nThis documents the results produced by the `audit documentation` command.\n\n## JSON Format\n```js\n{\n  \"results\": [\n    {\n      \"rule\": \"content-exists-check\",\n      \"description\": \"Check that backend documentation exists\",\n      \"pass\": true,\n      \"checks\": [\n        {\n          \"source\": \"backend\",\n          \"document\": \"CHANGELOG.md\",\n          \"uri\": \"document://backend/CHANGELOG.md\",\n          \"rule\": \"content-exists-check\",\n          \"check\": \"CONTENT_EXISTS\",\n          \"pass\": true,\n          \"message\": \"\"\n        }\n      ]\n    },\n    {\n      \"rule\": \"content-length-check\",\n      \"description\": \"Check that README has sufficient content\",\n      \"pass\": false,\n      \"checks\": [\n        {\n          \"source\": \"backend\",\n          \"document\": \"README.md\",\n          \"uri\": \"document://backend/README.md\",\n          \"rule\": \"content-length-check\",\n          \"check\": \"CONTENT_MIN_LENGTH\",\n          \"pass\": false,\n          \"message\": \"Content length is 277, minimum required is 10000.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### Fields\nA list of fields, their types, and a description of each.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| results | Array | The array of audit rule results |\n| results[n] | Object | An audit rule result |\n| results[n].rule | String | The rule ID from configuration, or auto-generated if not provided |\n| results[n].description | String | The rule description |\n| results[n].pass | Boolean | Whether all checks in the rule passed |\n| results[n].checks | Array | The array of individual check results |\n| results[n].checks[n] | Object | A check result |\n| results[n].checks[n].source | String | The documentation source ID |\n| results[n].checks[n].document | String | The document ID |\n| results[n].checks[n].section | Array OR undefined | If present, the section path |\n| results[n].checks[n].section[n] | String | A section path segment |\n| results[n].checks[n].uri | String | The document URI |\n| results[n].checks[n].rule | String | The rule ID this check belongs to |\n| results[n].checks[n].check | String | The type of check performed |\n| results[n].checks[n].pass | Boolean | Whether the check passed |\n| results[n].checks[n].message | String | The check message (may be empty) |\n\n### Checks\nThe list of available checks, their associated config property (under `audit.rules[n]`), and a description of each.\n\n| Check | Config Property | Description |\n|-------|-----------------|-------------|\n| CONTENT_EXISTS | `checks.content.exists` | Verifies that documentation matching the filter exists |\n| CONTENT_MIN_LENGTH | `checks.content.min-length` | Checks if content meets the minimum length requirement |\n| CONTENT_MATCHES_REGEX | `checks.content.matches-regex` | Validates content against a regular expression pattern |\n| CONTENT_MATCHES_PROMPT | `checks.content.matches-prompt` | Uses an LLM to check if content matches a custom prompt |\n| CONTENT_MATCHES_PURPOSE | `checks.content.matches-purpose` | Uses an LLM to verify content aligns with its stated purpose |\n| PURPOSE_EXISTS | `checks.purpose.exists` | Checks that a purpose is defined for the document or section |\n| TAGS_CONTAINS | `checks.tags.contains` | Verifies required tags are present |\n\nNote: When the `CONTENT_EXISTS` check fails to find matching content, the source, document, section, and uri fields will be empty",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/reference/cli.md",
    "uri": "document://hyaline/www/content/documentation/reference/cli.md",
    "content": "---\ntitle: \"Reference: CLI\"\ndescription: Command-line interface reference covering all commands, options, and usage examples\npurpose: Detail each command/sub-command of the Hyaline CLI\n---\n## Overview\nThis documents the commandline options for the Hyaline Command Line Interface (CLI).\n\n## Commands\nThe following commands and sub-commands are available within hyaline.\n\n**Common Options**:\n* `--debug` - (optional) Enables debug output\n\n## help\n`hyaline help` prints out usage information.\n\n**Options**:\n* (none)\n\n**Example**:\n```\n$ hyaline help\n```\n\n## version\n`hyaline version` prints out the currently installed version.\n\n**Options**:\n* (none)\n\n**Example**:\n```\n$ hyaline version\n```\n\n## extract documentation\n`hyaline extract documentation` extracts documentation from a documentation source. Please see the explanation for [extract](../explanation/extract.md) for more details.\n\n**Options**:\n* `--config` - (required) Path to the config file\n* `--output` - (required) Path of the data set to create (file must not already exist)\n\n**Example**:\n```\n$ hyaline extract documentation --config ./hyaline.yml --output ./documentation.db\n```\nExtract documentation from the system defined in the config file found at `./hyaline.yml` and create a current documentation dataset at `./documentation.db`.\n\n## check diff\n`hyaline check diff` checks a diff and outputs a list of recommended documentation updates.\n\n**Options**:\n* `--config` - (required) Path to the config file\n* `--documentation` - (required) Path to the current documentation data set (output of `hyaline extract documentation`)\n* `--path` - (optional) Path to the root of the repository to check. Defaults to `./`\n* `--base` - (required if `--base-ref` is not set, mutually exclusive with `--base-ref`) Base branch (where changes will be applied). Tries to resolve to a local branch first, then a remote branch (if there is a single remote), and finally a tag\n* `--base-ref` - (required if `--base` is not set, mutually exclusive with `--base`) Base reference (explicit commit hash or fully qualified reference). Passed directly to git resolution\n* `--head` - (required if `head-ref` is not set, mutually exclusive with `--head-ref`) Head branch (which changes will be applied). Tries to resolve to a local branch first, then a remote branch (if there is a single remote), and finally a tag\n* `--head-ref` - (required if `--head` is not set, mutually exclusive with `--head`) Head reference (explicit commit hash or fully qualified reference). Passed directly to git resolution\n* `--pull-request` - (optional) GitHub Pull Request to include in the change (`\u003cowner\u003e/\u003crepo\u003e/\u003cpr_number\u003e`)\n* `--issue` - (optional, multiple allowed) GitHub Issue to include in the change (`\u003cowner\u003e/\u003crepo\u003e/\u003cissue_number\u003e`). Accepts multiple issues by setting multiple times\n* `--output` - (required) Path of the output file to create (file must not already exist)\n\n**Example**:\n```\n$ hyaline check diff --config ./hyaline.yml --documentation ./documentation.db --path ./ --base main --head feat-1 --pull-request appgardenstudios/hyaline-example/1 --issue appgardenstudios/hyaline-example/2 --issue appgardenstudios/hyaline-example/3 --output ./recommendations.json\n```\nCheck what documentation in `./documentation.db` should be updated based on the changes between the `main` and `feat-1` branches as well as the configuration in `./hyaline.yml`. It takes into account the contents of the pull request `appgardenstudios/hyaline-example/1` and the issues `appgardenstudios/hyaline-example/2` and `appgardenstudios/hyaline-example/3`. The set of recommendations are output to `./recommendations.json`.\n\n**Example**:\n```\n$ hyaline check diff --config ./hyaline.yml --documentation ./documentation.db --path ./ --base-ref refs/heads/main --head-ref refs/remotes/origin/feat-1 --pull-request appgardenstudios/hyaline-example/1 --issue appgardenstudios/hyaline-example/2 --issue appgardenstudios/hyaline-example/3 --output ./recommendations.json\n```\nCheck what documentation in `./documentation.db` should be updated based on the changes between the `main` and `feat-1` refs as well as the configuration in `./hyaline.yml`. It takes into account the contents of the pull request `appgardenstudios/hyaline-example/1` and the issues `appgardenstudios/hyaline-example/2` and `appgardenstudios/hyaline-example/3`. The set of recommendations are output to `./recommendations.json`.\n\n## check pr\n`hyaline check pr` checks a pull request to see what documentation may need to be updated and adds any recommendations as a comment on the PR.\n\n**Options**:\n* `--config` - (required) Path to the config file\n* `--documentation` - (required) Path to the current documentation data set\n* `--pull-request` - (required) GitHub Pull Request to check (`\u003cowner\u003e/\u003crepo\u003e/\u003cpr_number\u003e`)\n* `--issue` - (optional, multiple allowed) GitHub Issue to include in the change (`\u003cowner\u003e/\u003crepo\u003e/\u003cissue_number\u003e`). Accepts multiple issues by setting multiple times\n* `--output` - (optional) Path to write the combined (current and previous merged together) recommendations to\n* `--output-current` - (optional) Path to write the current recommendations to\n* `--output-previous` - (optional) Path to write the previous recommendations to\n\n**Example**:\n```\n$ hyaline check pr --config ./hyaline.yml --documentation ./documentation.db --pull-request appgardenstudios/hyaline-example/1 --issue appgardenstudios/hyaline-example/2 --issue appgardenstudios/hyaline-example/3 --output ./recommendations.md\n```\nCheck what documentation in `./documentation.db` should be updated based on the changes in the pull request `appgardenstudios/hyaline-example/1` as well as the configuration in `./hyaline.yml`. It takes into account the content of the pull request `appgardenstudios/hyaline-example/1` and the issues `appgardenstudios/hyaline-example/2` and `appgardenstudios/hyaline-example/3`. If a comment already exists on the PR, the recommendations from the current run are merged with the recommendations from the previous run, and the comment is updated. Otherwise, a new comment is added with the current recommendations. The set of combined recommendations is output to `./recommendations.json`.\n\n**Example**:\n```\n$ hyaline check pr --config ./hyaline.yml --documentation ./documentation.db --pull-request appgardenstudios/hyaline-example/1 --issue appgardenstudios/hyaline-example/2 --issue appgardenstudios/hyaline-example/3 --output-current ./current-recommendations.md\n```\nCheck what documentation in `./documentation.db` should be updated based on the changes in the pull request `appgardenstudios/hyaline-example/1` as well as the configuration in `./hyaline.yml`. It takes into account the content of the pull request `appgardenstudios/hyaline-example/1` and the issues `appgardenstudios/hyaline-example/2` and `appgardenstudios/hyaline-example/3`. If a comment already exists on the PR, the recommendations from the current run are merged with the recommendations from the previous run, and the comment is updated. Otherwise, a new comment is added with the current recommendations. The set of recommendations from the current run is output to `./current-recommendations.json`\n\n## audit documentation\n`hyaline audit documentation` audits documentation against configurable rule checks to ensure compliance with documentation standards.\n\n**Options**:\n* `--config` - (required) Path to the config file\n* `--documentation` - (required) Path to the documentation database (output of `hyaline extract documentation`)\n* `--source` - (optional, multiple allowed) Only audit specific source ID(s). Can be specified multiple times\n* `--output` - (required) Path to write the audit results JSON file (file must not already exist)\n\n**Example**:\n```\n$ hyaline audit documentation --config ./hyaline.yml --documentation ./documentation.db --output ./audit-results.json\n```\nAudit all documentation in `./documentation.db` against the rules defined in `./hyaline.yml` and output the results to `./audit-results.json`.\n\n**Example**:\n```\n$ hyaline audit documentation --config ./hyaline.yml --documentation ./documentation.db --source source1 --source source2 --output ./audit-results.json\n```\nAudit only specific sources (`source1` and `source2`) in `./documentation.db` against the rules defined in `./hyaline.yml` and output the results to `./audit-results.json`.\n\n## merge documentation\n`hyaline merge documentation` merges 2 or more documentation data sets into a single output database.\n\n**Options**:\n* `--input` - (required, multiple allowed) Path of the sqlite databases to merge. At least 2 inputs are required\n* `--output` - (required) Path of the sqlite database to create\n\n**Example**:\n```\n$ hyaline merge documentation --input ./docs1.db --input ./docs2.db --output ./merged.db\n```\nMerge `./docs1.db` and `./docs2.db` into a single output database `./merged.db`.\n\n**Example**:\n```\n$ hyaline merge documentation --input ./docs1.db --input ./docs2.db --input ./docs3.db --output ./merged.db\n```\nMerge multiple documentation databases `./docs1.db`, `./docs2.db`, and `./docs3.db` into a single output database `./merged.db`.\n\n## serve mcp\n`hyaline serve mcp` starts an MCP server running locally over stdio and serves up the documentation produced by running `hyaline extract documentation`.\n\n**Options**:\n* `--documentation` - (required) Path to the SQLite database containing documentation\n\n**Example**:\n```\n$ hyaline serve mcp --documentation ./documentation.db\n```\nStart a local MCP server using the standard I/O transport and have it use the extracted documentation found in `./documentation.db`.",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/reference/config.md",
    "uri": "document://hyaline/www/content/documentation/reference/config.md",
    "content": "---\ntitle: \"Reference: Hyaline Config\"\ndescription: Configuration file schema including extract, check, and audit options\npurpose: Document the configuration options for Hyaline\n---\n## Overview\nThis documents the configuration options and format present in the Hyaline configuration file.\n\nNote that sections prefixed with **(Common)** are used in multiple places and are defined at the bottom.\n\n## Secrets\nHyaline has the ability to pull configuration values from environment variables. To use this functionality set the value of a key to `${ENV_VAR_NAME}` to use the value of the environment variable called `ENV_VAR_NAME`.\n\n```yaml\nllm:\n  provider: anthropic\n  model: claude-sonnet-4-20250514\n  key: ${HYALINE_ANTHROPIC_KEY}\n\ngithub:\n  token: ${HYALINE_GITHUB_PAT}\n```\n\nIn the configuration example above `llm.key` will be set to the value of the environment variable `HYALINE_ANTHROPIC_KEY`, and `github.token` will be set to the value of the environment variable `HYALINE_GITHUB_PAT`\n\n## LLM\nThe connection information to use when calling out to an LLM.\n\n```yaml\nllm:\n  provider: anthropic | testing\n  model: model-identifier\n  key: ${LLM_API_KEY}\n```\n\n**provider**: The provider to use when calling out to an LLM. possible values are `anthropic` and `testing`.\n\n**model**: The LLM model to use. See each provider's documentation for a list of possible values.\n\n**key**: The API key to use in requests. Note that this should be pulled from the environment and not hard-coded in the configuration file itself (see Secrets above)\n\n## GitHub\nThe configuration for calling out to GitHub (not used for extraction, just for PR and issue retrieval during checks)\n\n```yaml\ngithub:\n  token: ${GITHUB_PAT}\n```\n\n**token**: The GitHub token. Should be able to read pull requests and issues from relevant repositories when using `check diff`. Should be able to read pull requests, read issues, read/write issue comments, and read repo files when using `check pr`.\n\n## Extract\nStores the configuration to use when extracting documentation.\n\n```yaml\nextract:\n  source:\n  crawler:\n  extractors:\n  metadata:\n```\n\n**source**: Metadata assigned to the source being extracted.\n\n**crawler**: The crawler to use to extract documentation.\n\n**extractors**: A list of extractors to use when extracting documentation.\n\n**metadata**: Metadata to add to the extracted documents and sections.\n\n### Extract Source\nMetadata about the source being extracted.\n\n```yaml\nextract:\n  source:\n    id: Source1\n    description: A description of this source\n    root: git@github.com:appgardenstudios/hyaline.git\n```\n\n**id**: Each documentation source is assigned an ID. This ID must be unique across all documentation sources used within an organization. The ID must match the regex `/^[A-z0-9][A-z0-9_-]{0,63}$/`.\n\n**description**: A description of this documentation source.\n\n**root**: An optional override for the root of this documentation source. Normally this is calculated based on the crawler used, but this property can be used to override the derived root. See **Extract Crawler** for more information on how the source root is calculated.\n\n### Extract Crawler\nCrawler configuration for the documentation source being extracted.\n\nA note about the source root: it is calculated using the following algorithm based on the crawler that is configured\n\n- If `extract.source.root` is set then that value is used.\n- Else if the crawler type is `fs` then the value of `crawler.options.path` is used.\n- Else if the crawler type is `git`:\n  - If `crawler.options.repo` is set then that value is used.\n  - Else the value of `crawler.options.path` is used.\n- Else if the crawler type is `http` then the scheme and host from `crawler.options.baseUrl` is used (e.g. `https://example.com`)\n\n```yaml\nextract:\n  crawler:\n    type: fs | git | http\n    options: {...} # Dependent on the crawler type\n    include: [\"**/*.md\"]\n    exclude: [\"LICENSE.md\"]\n```\n\n**type**: The type of the crawler. For Documentation Sources there are three crawler types available: `fs`, `git`, and `http`. For more information see crawler details below.\n\n**options**: The options for the crawler. Note that these are specific to the type of crawler. Please see below for the options available for each crawler.\n\n**include**: The set of globs to include in the set of documentation during the crawling process. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths. See crawl option details below for how path comparisons are made and how relative glob paths work.\n\n**exclude**: The set of globs to exclude from the set of documentation during the crawling process. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths. See crawl option below for how path comparisons are made and how relative glob paths work.\n\n#### Extract Crawler Options (fs)\nCrawl a file system path. If you have a local git repository use the git crawler with the `path` option instead.\n\nNote that Include and Exclude globs are relative to the path specified.\n\nPlease see the explanation of [Extract](../explanation/extract.md) for more information.\n\n```yaml\nextract:\n  crawler:\n    type: fs\n    options:\n      path: path/to/documentation\n```\n\n**path**: The path that documentation will be crawled. If the path is not absolute it is joined with the current working directory to turn it into an absolute path. Note that the fs crawler uses [Root](https://pkg.go.dev/os@go1.24.1#Root) when scanning a directory, meaning that while symlinks are followed they must be within the Root to be crawled.\n\n#### Extract Crawler Options (git)\nCrawl a local or remote git repository. The behavior of the crawler when resolving a git repo is as follows:\n\n- If `clone` is set:\n  - If `path` is set, then the remote repo is cloned to path specified on disk\n  - Else the remote repo is cloned into an in-memory file system\n- Else:\n  - If `path` is not set, error\n  - Else open the local repository specified by `path` on disk\n\nWhen cloning, authorization is handled as follows:\n\n- If `auth.type` is `http`:\n  - If `auth.username` is set, then basic auth uses that for the username\n  - Else basic auth uses the value `git` for the username\n  - Finally basic auth uses `auth.password` for the password\n- If `auth.type` is `ssh`:\n  - If `auth.user` is set, then ssh auth uses that for the user\n  - Else ssh auth uses the value `git` for the user\n  - Finally ssh auth uses the PEM key specified by `auth.pem` as the ssh auth key. Note that if `auth.password` is set it is used as the password when decoding in the PEM key.\n\nFor more information on how extraction works please see the documentation for [Extract](../explanation/extract.md).\n\nNote that Include and Exclude globs are relative to the root of the repository.\n\n```yaml\nextract:\n  crawler:\n    type: git\n    options:\n      path: path/to/repo\n      branch: main\n```\n\n```yaml\nextract:\n  crawler:\n    type: git\n    options:\n      path: path/to/repo\n      repo: git@github.com:appgardenstudios/hyaline.git\n      branch: main\n      clone: true\n      auth:\n        type: ssh\n        options:\n          user: git\n          pem: -----BEGIN OPENSSH... # Or use an env var like ${HYALINE_SSH_PEM}\n          password: pem-password... # Or use an env var like ${HYALINE_SSH_PWD}\n```\n\n```yaml\nextract:\n  crawler:\n    type: git\n    options:\n      repo: https://github.com/appgardenstudios/hyaline-example.git\n      branch: main\n      clone: true\n      auth:\n        type: http\n        options:\n          username: git\n          password: github_pat_... # Or use an env var like ${HYALINE_GITHUB_PAT}\n```\n\n**path**: The local path to the repository. If the path is not absolute it is joined with the current working directory to turn it into an absolute path. If `clone` is false the repository at path is opened. If `clone` is true the repository is cloned to the path before being opened. `path` is required if `clone` is false.\n\n**repo**: The remote git repository to use. Can be an ssh or http(s) URL. Only required if `clone` is true.\n\n**branch**: The branch to crawl. If not set will default to `main`. Tries to resolve to a local branch first, then a remote branch (if there is a single remote), and finally a tag.\n\n**clone**: Boolean specifying wether or not to clone the repository before opening. If true `repo` is also required. Defaults to false.\n\n**auth**: Authentication information for cloning the repository. Note that if no auth is specified Hyaline will still attempt to clone, and if the repo URL is ssh your local ssh configuration will be used automatically.\n\n**auth.type**: The type of authentication. Can be either `ssh` or `http`. Type should match the type of repo URL supplied (Hyaline does __not__ attempt to auto-detect which auth option to use based on the repo URL).\n\n**auth.options**: Authentication options based on the type specified.\n\n**auth.options.user**: (`ssh`) The ssh user to use when cloning the repository. Defaults to `git`.\n\n**auth.options.pem**: (`ssh`) The contents of the private key to use when cloning the repository. Note that the encoded pem must contain the standard newlines, so use double quotes a la `\"-----BEGIN OPENSSH PRIVATE KEY-----\\n...\" when exporting it to the relevant environment variable.\n\n**auth.options.username**: (`http`) The http username to use when cloning. Defaults to `git`.\n\n**auth.options.password**: (`ssh` AND `http`) For `ssh`, the encryption password to use if the PEM contains a password encrypted PEM block. For `http` the password to use when cloning (will usually be a GitHub PAT or equivalent). \n\n#### Extract Crawler Options (http)\nCrawl a local or remote http or https website.\n\nNote that Include and Exclude globs are relative to the baseURL.\n\nPlease see the explanation of [Extract](../explanation/extract.md) for more information.\n\n```yaml\nextract:\n  crawler:\n    type: http\n    options:\n      baseUrl: https://www.hyaline.dev/\n      start: ./documentation\n      headers:\n        custom-header: My Header Value\n```\n\n**baseUrl**: The base URL to start with. The baseUrl will be the starting URL if `start` is not defined. Also note that the crawler is limited to the same domain as that on the baseUrl.\n\n**start**: An (optional) starting path relative to the baseURL. If set the crawler will start on the `baseUrl` joined with `start` path.\n\n**headers**: A set of (optional) headers to include with each request.\n\n### Extract Extractors\nExtractor configuration for the documentation source being extracted.\n\nA note about the extractor being used. The first extractor that matches the document path (relative to the root of the crawler) is used. If there is no extractor configured to handle the document an error is returned.\n\nPlease see the explanation of [Extract](../explanation/extract.md) for more information.\n\n```yaml\nextract:\n  extractors:\n    - type: md | html\n      options: # Dependent on the extractor type\n      include: [\"**/*.md\"]\n      exclude: []\n```\n\n**type**: The type of documentation extractor. `md` and `html` are the currently supported types.\n\n**options**: Options used when extracting documentation and converting it into markdown (if applicable).\n\n**include**: The set of globs to match against during the extraction process. Crawled documents must match at least one glob in order to be extracted using the extractor. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths.\n\n**exclude**: The set of globs to exclude from the set of documentation during the extraction process. Crawled documents must match at none of these globs in order to be extracted using the extractor. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths.\n\n#### Extract Extractors Options\nExtractor options based on the type of the extractor.\n\n```yaml\nextract:\n  extractors:\n    - type: md\n      options: # There are no options for the md extractor\n```\n\n```yaml\nextract:\n  extractors:\n    - type: html\n      options:\n        selector: main\n```\n\n**selector**: A css-style selector used to extract documentation when the type of documentation is html. Only documentation that is a child of this selector will be extracted. Uses [Cascadia](https://pkg.go.dev/github.com/andybalholm/cascadia). Please see the explanation of [Extract](../explanation/extract.md) for more information.\n\n### Extract Metadata\nConfiguration about what metadata to add to the extracted documentation.\n\nNote that the specified metadata (`purpose` and/or `tags`) is added to each document or section that matches. If only `document` is specified only matching documents have the metadata applied. If both `document` and `section` are specified only sections matching both `document` and `section` have the metadata applied.\n\nNote that metadata is applied sequentially, meaning that any overlapping documents or sections will have their purpose(s) overwritten and the tags added to.\n\n```yaml\nextract:\n  metadata:\n    - document: README.md\n      section: About\n      purpose: My document or section purpose\n      tags:\n        - key: system\n          value: my-app\n```\n\n**document**: A glob to match a set of documents. Documents must match this extractor to have metadata applied. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths. `document` is required.\n\n**section**: A glob to match a set of sections. Sections must match this extractor to have metadata applied. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths. `section` is optional.\n\n**purpose**: The purpose to associate with the specified document or section.\n\n**tags**: The set of tags to associate with the specified document or section.\n\n**tags[].key**: The key of the tag to add. Must match the regex `/^[A-z0-9][A-z0-9_-]{0,63}$/`.\n\n**tags[].value**: The value of the tag to add. Must match the regex `/^[A-z0-9][A-z0-9_-]{0,63}$/`.\n\n## Check\nStores the configuration to use when checking documentation.\n\n```yaml\ncheck:\n  code:\n  documentation:\n  options:\n```\n\n**code**: The set of code to evaluate when checking for recommended updates.\n\n**documentation**: The set of documentation to include when evaluating which documents/sections need to be updated.\n\n**options**: Options used to configure how the check process runs.\n\n### Check Code\nDetermine what code is included when checking for recommended updates. Only code that is included is used when evaluating what documentation should be updated, so only include code that affects documentation (i.e. source code and not tests or tool configuration files).\n\n```yaml\ncheck:\n  code:\n    include:\n      - \"**/*.js\"\n      - \"package.json\"\n    exclude:\n      - \"old/**/*\"\n      - \"**/*.test.js\"\n```\n\n**include**: The set of globs dictating what code files to include and consider during the check process. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths. Each glob is relative to the root of the repository.\n\n**exclude**: The set of globs dictating what code files to exclude and not consider during the check process. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths. Each glob is relative to the root of the repository.\n\n### Check Documentation\nDetermine what documentation should be included in the set of documentation considered. Note that documents and sections must be included and not excluded to be considered when recommending what documentation to update.\n\n```yaml\ncheck:\n  documentation:\n    include:\n      - source: \"my-app\"\n        document: \"**/*\"\n      - source: \"**/*\"\n        tags:\n          - key: system\n            value: my-app\n      - uri: document://product-docs/**/*\n    exclude:\n      - source: my-app\n        document: README.md\n        section: License\n```\n\n**include**: A set of Documentation Filters (see below) dictating what documentation is in scope of this check.\n\n**exclude**: A set of Documentation Filters (see below) dictating what documentation is not in scope of this check.\n\n### Check Options\nVarious options used when checking what documentation needs to be updated based on a code change.\n\n```yaml\ncheck:\n  options:\n    detectDocumentationUpdates:\n    updateIf:\n```\n\n**detectDocumentationUpdates**: Option to detect documentation updates and mark recommendations as changed.\n\n**updateIf**: Options to link code and documents so that code changes will generate documentation update recommendations based on the configuration.\n\n#### Check Options DetectDocumentationUpdates\nDetect documentation updates and mark recommendations as changed.\n\n```yaml\ncheck:\n  options:\n    detectDocumentationUpdates:\n      source: my-app\n```\n\n**source**: If set, Hyaline will mark documents and sections as changed if they 1) have the same source and 2) the document was touched as a part of the change being examined (i.e. the document was changed in the diff or the pull request)\n\n#### Check Options UpdateIf\nConfigure Hyaline to recommend that documentation be updated if a corresponding file change occurs.\n\n```yaml\ncheck:\n  options:\n    updateIf:\n      touched: [...]\n      added: [...]\n      modified: [...]\n      deleted: [...]\n      renamed: [...]\n```\n\n**touched**: A list of UpdateIf Entries (see UpdateIf Entry below) detailing that this document should be updated if any matching files are touched (e.g. added, modified, deleted, or renamed).\n\n**added**: A list of UpdateIf Entries (see UpdateIf Entry below) detailing that this document should be updated if any matching files are added (e.g. created or inserted).\n\n**modified**: A list of UpdateIf Entries (see UpdateIf Entry below) detailing that this document should be updated if any matching files are modified (e.g. changed).\n\n**deleted**: A list of UpdateIf Entries (see UpdateIf Entry below) detailing that this document should be updated if any matching files are deleted (e.g. removed).\n\n**renamed**: A list of UpdateIf Entries (see UpdateIf Entry below) detailing that this document should be updated if any matching files are renamed (e.g. moved).\n\n##### **Check Options UpdateIf Entry**\nAn entry that specifies that matching documentation should be updated if matching code was changed.\n\n```yaml\ncheck:\n  options:\n    updateIf:\n      touched: # A list of UpdateIf Entries\n        - code:\n            path: \"src/routes.js\"\n          documentation: # A Documentation Filter\n            source: \"my-app\"\n            document: \"docs/routes.md\"\n```\n\n**code**: The code that triggers the update.\n\n**code.path**: A glob dictating what code files to match. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths. The glob is relative to the root of the repository.\n\n**documentation**: The Documentation Filter (see below) that determines which documentation to match.\n\n## Audit\nStores the configuration to use when auditing documentation.\n\n```yaml\naudit:\n  rules:\n```\n\n**rules**: A list of audit rules to evaluate against the documentation.\n\n### Audit Rules\nDefine specific checks to run against your documentation.\n\n```yaml\naudit:\n  rules:\n    - id: \"content-exists-check\"\n      description: \"Check that critical documentation exists\"\n      documentation:\n        - source: \"**/*\"\n          document: \"README.md\"\n      ignore:\n        - source: \"internal\"\n      checks:\n        content:\n        purpose:\n        tags:\n```\n\n**id**: A unique identifier for the rule. Must match the regex `/^[A-z0-9][A-z0-9_-]{0,63}$/`. If not provided, an auto-generated ID will be assigned (e.g., `_0`, `_1`).\n\n**description**: A human-readable description of what this rule audits.\n\n**documentation**: A list of Documentation Filters (see below) dictating what documentation this rule applies to. At least one filter is required.\n\n**ignore**: A list of Documentation Filters (see below) dictating what documentation to exclude from this rule's evaluation.\n\n**checks**: The validation checks to perform on matching documentation.\n\n#### Audit Rules Checks Content\nValidate the content of documentation.\n\n```yaml\naudit:\n  rules:\n    - checks:\n        content:\n          exists: true\n          min-length: 100\n          matches-regex: \"(?i)installation\"\n          matches-prompt: \"Does this document contain deployment instructions?\"\n          matches-purpose: true\n```\n\n**exists**: Boolean indicating whether the content must exist. When true, the check passes if at least one document or section matches the documentation filters. When false or not set, this check is disabled.\n\n**min-length**: Minimum required content length in characters. The check fails if the content is shorter than this value. When not set, this check is disabled.\n\n**matches-regex**: A regular expression pattern that the content must match. When not set, this check is disabled.\n\n**matches-prompt**: An LLM prompt to evaluate against the content. The LLM will assess whether the content satisfies the prompt's criteria. When not set, this check is disabled.\n\n**matches-purpose**: Boolean indicating whether the content should match its defined purpose. Requires the document or section to have a purpose defined. When false or not set, this check is disabled.\n\n#### Audit Rules Checks Purpose\nValidate that documentation has defined purposes.\n\n```yaml\naudit:\n  rules:\n    - checks:\n        purpose:\n          exists: true\n```\n\n**exists**: Boolean indicating whether a purpose must be defined for the documentation. When false or not set, this check is disabled.\n\n#### Audit Rules Checks Tags\nValidate the presence of specific tags on documentation.\n\n```yaml\naudit:\n  rules:\n    - checks:\n        tags:\n          contains:\n            - key: \"type\"\n              value: \".*guide\"\n            - key: \"level\"\n              value: \"beginner\"\n```\n\n**contains**: A list of tags that must be present on the documentation. When set, the check passes if documentation has all of the listed tags. When not set, this check is disabled.\n\n**contains[n].key**: The tag key to check for. Uses regex pattern matching.\n\n**contains[n].value**: The tag value to check for. Uses regex pattern matching.\n\n## (Common) Documentation Filter\nA filter to use to select a subset of documentation.\n\n```yaml\ncheck:\n  documentation:\n    include: # An array of Documentation Filters\n      - source: \"my-app\"\n      - source: \"api\"\n        document: \"my-app/**/*\"\n      - source: \"security\"\n        document: \"frontend.md\"\n        section: \"my-app\"\n      - source: \"**/*\"\n        tags:\n          - key: system\n            value: my-app\n      - uri: document://product-docs/**/*\n```\n\n**source**: A glob that matches against a document or section's source ID. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths. Must be set if `uri` is not set.\n\n**document**: A glob that matches against a document or section's document ID. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths.\n\n**section**: A glob that matches against a section's section ID. This uses the [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) package to match paths.\n\n**tags**: A set of tags to match the document or section against.\n\n**tags[n].key**: A tag key. Must match `/^[A-z0-9][A-z0-9_-]{0,63}$/`\n\n**tags[n].value**: A tag value. Must match `/^[A-z0-9][A-z0-9_-]{0,63}$/`\n\n**uri**: An encoded document URI in the format of `document://\u003csource-id\u003e/\u003cpath/of/document.md\u003e#\u003cpath/of/section\u003e`. Must start with `document://` and contain at least a source and document glob. Each section (source, document, section) must be a valid [doublestar](https://pkg.go.dev/github.com/bmatcuk/doublestar/v4) glob. Must be set if `source` is not set.",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/reference/data-set.md",
    "uri": "document://hyaline/www/content/documentation/reference/data-set.md",
    "content": "---\ntitle: \"Reference: Documentation Data Set\"\ndescription: SQLite database schema for current and change data sets\npurpose: Detail the schema and usage of the Hyaline data set\n---\n\n## Overview\nThis documents the database schema of the Hyaline Documentation Data Set as generated by the command `hyaline extract documentation` and stored in sqlite.\n\n![Data Set Schema](_img/data-set-schema.svg)\n\n## Tables\nThe following tables make up a Hyaline Documentation Data Set.\n\n### SOURCE\nThe Documentation Source, along with some metadata.\n\n- **ID** - The source ID, pulled from the configuration. This must be globally unique and match the regex `/^[A-z0-9][A-z0-9_-]{0,63}$/`.\n- **DESCRIPTION** - A description of the source, used for informing the llm about the purpose and contents of the documents and sections contained within this source. May be blank.\n- **CRAWLER** - The type of the extractor. One of `fs`, `git`, `http`.\n- **ROOT** - The \"root\" of this documentation source. The document's path should always be relative to this root. ROOT is used during the check diff/pr process to determine which documents and/or sections have been updated. Must not be blank.\n\n**Primary Key**: (ID)\n\n### DOCUMENT\nA document.\n\n- **ID** - The ID of the document, determined by the path to the document relative to the root of the source (`SOURCE.ROOT`). Must be unique within the source. Must not be blank.\n- **SOURCE_ID** - The ID if the source this document belongs to. Points to `SOURCE.ID`.\n- **TYPE** - The type of document. One of `md`, `html`.\n- **PURPOSE** - The purpose of this document. Set via metadata during the extraction process. May be blank.\n- **RAW_DATA** - The raw document in its original form. May be blank.\n- **EXTRACTED_DATA** - The markdown representation of the document after being fully extracted. May be blank.\n\n**Primary Key**: (ID, SOURCE_ID)\n\n### SECTION\nA section within a document.\n\n- **ID** - The ID of the section, determined by the path to the section relative to the root of the document (`Section 1 \u003e Section 1.1` becomes `Section 1/Section 1.1`. Note that slashes (`/`) are replaced with `_` in the section names during extraction. Must be unique within the source. May not be blank.\n- **DOCUMENT_ID** - The ID if the document this section belongs to. Points to `DOCUMENT.ID`. Must not be blank.\n- **SOURCE_ID** - The ID if the source this document belongs to. Points to `SOURCE.ID`. Must not be blank.\n- **PARENT_ID** - The ID if the section this section belongs to. Points to `SECTION.ID`. Must not be blank.\n- **PEER_ORDER** - The order of the section in relation to its peers. 0-based. Must not be blank.\n- **NAME** - The original name of the section (including any `/`). May be blank (if section name is empty).\n- **PURPOSE** - The purpose of this section. Set via metadata during the extraction process. May be blank.\n- **EXTRACTED_DATA** - The markdown contents of this section. Note that any child sections are included in this data. May be blank.\n\n**Primary Key**: (ID, DOCUMENT_ID, SOURCE_ID)\n\n### DOCUMENT_TAG\nA tag associated with a document.\n\n- **SOURCE_ID** - The ID if the source this tag belongs to. Points to `SOURCE.ID`. Must not be blank.\n- **DOCUMENT_ID** - The ID if the document this tag belongs to. Points to `DOCUMENT.ID`. Must not be blank.\n- **TAG_KEY** - The value of the key for this tag (aka the tag name). Must match the regex `/^[A-z0-9][A-z0-9_-]{0,63}$/`. Note that the prefix `_` is reserved for internal use if needed in the future.\n- **TAG_VALUE** - The value of this tag (aka the tag value). Must match the regex `/^[A-z0-9][A-z0-9_-]{0,63}$/`.\n\n**Primary Key**: (SOURCE_ID, DOCUMENT_ID, TAG_KEY, TAG_VALUE)\n\n**Index**: (TAG_KEY, TAG_VALUE)\n\n### SECTION_TAG\nA tag associated with a section.\n\n- **SOURCE_ID** - The ID if the source this tag belongs to. Points to `SOURCE.ID`. Must not be blank.\n- **DOCUMENT_ID** - The ID if the document this tag belongs to. Points to `DOCUMENT.ID`. Must not be blank.\n- **SECTION_ID** - The ID if the section this tag belongs to. Points to `SECTION.ID`. Must not be blank.\n- **TAG_KEY** - The value of the key for this tag (aka the tag name). Must match the regex `/^[A-z0-9][A-z0-9_-]{0,63}$/`. Note that the prefix `_` is reserved for internal use if needed in the future.\n- **TAG_VALUE** - The value of this tag (aka the tag value). Must match the regex `/^[A-z0-9][A-z0-9_-]{0,63}$/`.\n\n**Primary Key**: (SOURCE_ID, DOCUMENT_ID, SECTION_ID, TAG_KEY, TAG_VALUE)\n\n**Index**: (TAG_KEY, TAG_VALUE)",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/reference/github-actions.md",
    "uri": "document://hyaline/www/content/documentation/reference/github-actions.md",
    "content": "---\ntitle: \"Reference: GitHub Actions\"\ndescription: An overview of the available GitHub actions to integrate Hyaline into a workflow\npurpose: Detail the functionality and usage of Hyaline within GitHub Actions\n---\n## Overview\n\n\u003cdiv class=\"portrait\"\u003e\n\n![Overview](_img/github-actions-overview.svg)\n\nHyaline comes with a set of [GitHub Actions](https://github.com/features/actions) that allows you to setup and use Hyaline within a GitHub workflow.\n\nWhen a developer pushes code to a Pull Request in GitHub, one or more GitHub Actions are triggered. Those actions can then run jobs such as checking out code, installing Hyaline, ensuring a pull request is updating all applicable documentation, etc.\n\nHyaline provides the following GitHub Actions:\n\n- **Setup** - Install and Setup Hyaline in your workflow\n- **Check PR** - Check a PR for recommended documentation updates\n\n\u003c/div\u003e\n\n## Setup\nThe [setup action](https://github.com/appgardenstudios/hyaline-actions/tree/main/setup) provides an easy way to download and install the Hyaline CLI on your GitHub Actions runner so you can run Hyaline commands.\n\nThe default configuration installs a hard-coded version of Hyaline that is updated alongside major Hyaline releases:\n```yaml\nsteps:\n  - uses: appgardenstudios/hyaline-actions/setup@v1\n```\n\nA specific version of the Hyaline CLI can be installed using:\n```yaml\nsteps:\n  - uses: appgardenstudios/hyaline-actions/setup@v1\n    with:\n      version: \"v1-YYYY-MM-DD-HASH\"\n```\n\n### Inputs\nThe action supports the following inputs:\n\n* `version` - (optional) The version of the Hyaline CLI to install. This version must be present as a tagged [GitHub Release](https://github.com/appgardenstudios/hyaline/releases) and must be later than `v1-2025-08-08`.\n\n### Outputs\nThis action is not configured to provide any outputs.\n\n## Check PR\nThe [check-pr action](https://github.com/appgardenstudios/hyaline-actions/tree/main/check-pr) provides the ability to check a pull request and recommend documentation updates based on the change (the results of which are added as a comment on the Pull Request).\n\nNote that Hyaline will update (overwrite) older versions of its own comment so that you only have a single comment from Hyaline containing all of its recommendations.\n\nThis is a sample workflow file that will configure Hyaline to check your PRs when they are not in a draft state:\n```yaml\non:\n  pull_request:\n    types: [opened, reopened, synchronize, ready_for_review]\n\njobs:\n  check-pr:\n    runs-on: ubuntu-latest\n    # Only run if PR is NOT a draft\n    if: ${{ github.event.pull_request.draft == false }}\n    permissions:\n      pull-requests: write\n    steps:\n      - name: Setup Hyaline\n        uses: appgardenstudios/hyaline-actions/setup@v1\n      - name: Check PR\n        uses: appgardenstudios/hyaline-actions/check-pr@v1\n        with:\n          config: ./hyaline.yml\n          repository: ${{ github.repository }}\n          pr_number: ${{ github.event.pull_request.number }}\n        env:\n          # Set env vars needed by the hyaline CLI when interpolating the hyaline config\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          ANTHROPIC_KEY: ${{ secrets.ANTHROPIC_KEY }}\n```\n\nNote that the `check-pr` job above requires the permission `pull-requests: write` to leave a comment on the pull request.\n\n### Inputs\nThe action supports the following inputs:\n\n* `config` - (required) The path to the hyaline configuration file relative to the root of the repository.\n* `repository`  - (optional) The current GitHub repository (owner/repo).\n* `pr_number` - (required) The pull request number.\n\n### Outputs\nThis action provides the following outputs:\n\n* `completed_recommendations` - The number of recommendations that have been checked and marked as completed.\n* `outstanding_recommendations` - The number of recommendations that are unchecked and not marked as completed.\n* `total_recommendations` - The total number of recommendations (sum of `completed_recommendations` and `outstanding_recommendations`)",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/reference/mcp.md",
    "uri": "document://hyaline/www/content/documentation/reference/mcp.md",
    "content": "---\ntitle: \"Reference: MCP\"\ndescription: MCP server tools and prompts for making extracted documentation available to LLMs\npurpose: Detail the functionality of Hyaline's MCP server\n---\n## Overview\nHyaline provides a built-in MCP server that can make the [current data set](./data-set.md) extracted by Hyaline's [extract documentation](../explanation/extract.md) command available to LLMs. For information on how to set up and run the MCP server please see the [how to](../how-to/run-mcp.md) or the [cli reference](./cli.md).\n\n## Tools\nHyaline's MCP server provides the following tools:\n\n### list_documents\nList all documents at or under the specified URI path, or all documents if no URI is provided. URIs follow this pattern: `document://\u003csource-id\u003e/\u003cdocument-id\u003e[?\u003ckey\u003e=\u003cvalue\u003e]`.\n\n**Arguments**\n- `document_uri` - The URI path to list documents from (can be partial). Format: `document://\u003csource-id\u003e/\u003cdocument-id\u003e[?\u003ckey\u003e=\u003cvalue\u003e]`. Query parameters filter results by tags (multiple values fo the same key are comma-separated). If not provided, lists all documents.\n\n**Output**\nA list of the documents available for the given URI. If a full URI is not given, documents scoped to the prefix are returned.\n\n### get_documents\nGet the contents of documents matching the specified URI, or all documents if no URI provided. Document URIs follow this pattern: `document://\u003csource-id\u003e/\u003cdocument-id\u003e[?\u003ckey\u003e=\u003cvalue\u003e]`.\n\n**Arguments**\n- `document_uri` - The URI specifying which documents to retrieve (can be partial). Format: `document://\u003csource-id\u003e/\u003cdocument-id\u003e[?\u003ckey\u003e=\u003cvalue\u003e]`. Query parameters filter results by tags. If not provided, retrieves all documents.\n\n**Output**\nOne or more documents (including the contents of each document).\n\n## Prompts\nHyaline's MCP server provides the following prompts:\n\n### answer_question\nAnswer a question based on available documentation.\n\n**Arguments**\n- `question` - The question to answer",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/reference/recommendations.md",
    "uri": "document://hyaline/www/content/documentation/reference/recommendations.md",
    "content": "---\ntitle: \"Reference: Recommendations\"\ndescription: JSON output format for recommendations produced by the check diff and check pr commands\npurpose: Detail the JSON output format for recommendations produced by the check diff and check pr commands\n---\n## Overview\nThis documents the recommendations produced by the `check diff` and `check pr` commands.\n\n## JSON Format\n```js\n{\n  \"recommendations\": [\n    {\n      \"source\": \"my-app\",\n      \"document\": \"README.md\",\n      \"section\": [\n        \"Running Locally\"\n      ],\n      \"recommendation\": \"Consider reviewing and updating this documentation\",\n      \"reasons\": [\n        {\n          \"reason\": \"Update this section if any files matching package.json were modified\"\n        }\n      ],\n      \"changed\": true,\n      \"checked\" true\n    }\n  ],\n  \"head\": \"b4c5c736fd31d30a04067af9c0929d7dc42f049e\",\n  \"base\": \"b564300250288b332d50e2925dbd25e98831adbd\"\n}\n```\n\n### Fields\nA list of fields, their types, and a description of each.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| recommendations | Array | The array of recommendations |\n| recommendations[n] | Object | A result |\n| recommendations[n].source | String | The documentation source ID |\n| recommendations[n].document | String | The name of the document |\n| recommendations[n].section | Array | If not empty, the section (including parent sections) |\n| recommendations[n].section[n] | String | The section name |\n| recommendations[n].recommendation | String | The recommendation |\n| recommendations[n].reasons | Array | A list of reasons |\n| recommendations[n].reasons[n] | Object | A reason |\n| recommendations[n].reasons[n].reason | String | The human-readable reason |\n| recommendations[n].changed | Boolean | If the document or section was changed in the diff |\n| recommendations[n].checked | Boolean | If the recommendation has been checked (such as by updating the recommended document or section) |\n| head | String | The commit hash used as the head reference in the diff |\n| base | String | The commit hash used as the base reference in the diff |",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/documentation/roadmap.md",
    "uri": "document://hyaline/www/content/documentation/roadmap.md",
    "content": "---\ntitle: Roadmap\ndescription: \"Current development focus and upcoming features planned for Hyaline.\"\npurpose: Explain at a high level what is coming for Hyaline\n---\n## Main Focus\n* Gathering and responding to feedback\n* Implementing centralized configuration\n\n## Up Next\n* Improving the onboarding experience\n* Recommendation refinements",
    "tags": []
  },
  {
    "source": "hyaline",
    "document": "www/content/security.md",
    "uri": "document://hyaline/www/content/security.md",
    "content": "---\ntitle: Security\npurpose: Provide an overview of the security practices and policies of Hyaline\n---\n\n# Security\n\nHyaline is designed with security and privacy as core principles. This page outlines our security practices and what you can expect when using Hyaline.\n\n## Data Privacy\n\n**We don't see your code or documentation.** Hyaline runs entirely on your infrastructure - whether that's your local machine, CI environment, or your own servers. Your source code and documentation never leave your control.\n\n**No data collection.** Hyaline does not send usage analytics, telemetry, or any other data to our servers. We have no visibility into how you use the tool or what content you're processing.\n\n## Local Operation\n\nHyaline operates as a standalone CLI tool that:\n\n- Reads your source code and documentation from locations you specify\n- Writes data to a SQLite database at a path you control\n- Runs an MCP server locally for integration with AI tools\n\n## Network Communications\n\nHyaline only makes network requests when you explicitly configure it to:\n\n- **Source code repositories**: If you configure git extractors to clone remote repositories\n- **Documentation sources**: If you configure HTTP extractors to crawl documentation websites\n- **LLM API calls**: If you provide an API key for LLM services (like Anthropic's Claude)\n\nThese connections are made directly from your environment to the configured services - Hyaline does not proxy or intercept this traffic.\n\n## File System Access\n\nHyaline requires:\n\n- **Read access** to your source code and documentation files as specified in your configuration\n- **Write access** to create and update the SQLite database you specify\n\nThe tool respects standard file system permissions and only accesses files within the paths you configure.\n\n## Authentication \u0026 Secrets\n\nWhen working with remote repositories or LLM APIs, Hyaline supports:\n\n- Environment variable substitution for API keys and tokens\n- SSH key authentication for git repositories\n- HTTP authentication for private repositories\n\n**Best practice**: Store all sensitive credentials as environment variables rather than hard-coding them in configuration files.\n\n## MCP Server\n\nThe MCP server runs locally and provides your documentation to AI tools. Currently:\n\n- No authentication or access controls are implemented\n- The server only runs on your local machine\n- Access is limited to applications you explicitly connect to the server\n\n## Reporting Security Issues\n\nIf you discover a security vulnerability in Hyaline, please report it to us at:\n\n**Email**: [support@hyaline.dev](mailto:support@hyaline.dev)\n\nWe take security issues seriously and will respond promptly to any reports.",
    "tags": [
      {
        "key": "type",
        "value": "security"
      }
    ]
  }
]